/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["WebRTCMetrics"] = factory();
	else
		root["WebRTCMetrics"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n\n\n//# sourceURL=webpack://WebRTCMetrics/./node_modules/loglevel/lib/loglevel.js?");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : 0\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n\n\n//# sourceURL=webpack://WebRTCMetrics/./node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "./node_modules/short-unique-id/dist/short-unique-id.js":
/*!**************************************************************!*\
  !*** ./node_modules/short-unique-id/dist/short-unique-id.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("var ShortUniqueId = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropSymbols = Object.getOwnPropertySymbols;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __propIsEnum = Object.prototype.propertyIsEnumerable;\n  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n  var __spreadValues = (a, b) => {\n    for (var prop in b || (b = {}))\n      if (__hasOwnProp.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols)\n      for (var prop of __getOwnPropSymbols(b)) {\n        if (__propIsEnum.call(b, prop))\n          __defNormalProp(a, prop, b[prop]);\n      }\n    return a;\n  };\n  var __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\n  var __export = (target, all) => {\n    __markAsModule(target);\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n\n  // src/index.ts\n  var src_exports = {};\n  __export(src_exports, {\n    DEFAULT_UUID_LENGTH: () => DEFAULT_UUID_LENGTH,\n    default: () => ShortUniqueId\n  });\n\n  // package.json\n  var version = \"4.4.4\";\n\n  // src/index.ts\n  var DEFAULT_UUID_LENGTH = 6;\n  var DEFAULT_OPTIONS = {\n    dictionary: \"alphanum\",\n    shuffle: true,\n    debug: false,\n    length: DEFAULT_UUID_LENGTH\n  };\n  var _ShortUniqueId = class extends Function {\n    constructor(argOptions = {}) {\n      super();\n      this.dictIndex = 0;\n      this.dictRange = [];\n      this.lowerBound = 0;\n      this.upperBound = 0;\n      this.dictLength = 0;\n      this._digit_first_ascii = 48;\n      this._digit_last_ascii = 58;\n      this._alpha_lower_first_ascii = 97;\n      this._alpha_lower_last_ascii = 123;\n      this._hex_last_ascii = 103;\n      this._alpha_upper_first_ascii = 65;\n      this._alpha_upper_last_ascii = 91;\n      this._number_dict_ranges = {\n        digits: [this._digit_first_ascii, this._digit_last_ascii]\n      };\n      this._alpha_dict_ranges = {\n        lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n        upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]\n      };\n      this._alpha_lower_dict_ranges = {\n        lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii]\n      };\n      this._alpha_upper_dict_ranges = {\n        upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]\n      };\n      this._alphanum_dict_ranges = {\n        digits: [this._digit_first_ascii, this._digit_last_ascii],\n        lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n        upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]\n      };\n      this._alphanum_lower_dict_ranges = {\n        digits: [this._digit_first_ascii, this._digit_last_ascii],\n        lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii]\n      };\n      this._alphanum_upper_dict_ranges = {\n        digits: [this._digit_first_ascii, this._digit_last_ascii],\n        upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]\n      };\n      this._hex_dict_ranges = {\n        decDigits: [this._digit_first_ascii, this._digit_last_ascii],\n        alphaDigits: [this._alpha_lower_first_ascii, this._hex_last_ascii]\n      };\n      this.log = (...args) => {\n        const finalArgs = [...args];\n        finalArgs[0] = `[short-unique-id] ${args[0]}`;\n        if (this.debug === true) {\n          if (typeof console !== \"undefined\" && console !== null) {\n            return console.log(...finalArgs);\n          }\n        }\n      };\n      this.setDictionary = (dictionary, shuffle) => {\n        let finalDict;\n        if (dictionary && Array.isArray(dictionary) && dictionary.length > 1) {\n          finalDict = dictionary;\n        } else {\n          finalDict = [];\n          let i;\n          this.dictIndex = i = 0;\n          const rangesName = `_${dictionary}_dict_ranges`;\n          const ranges = this[rangesName];\n          Object.keys(ranges).forEach((rangeType) => {\n            const rangeTypeKey = rangeType;\n            this.dictRange = ranges[rangeTypeKey];\n            this.lowerBound = this.dictRange[0];\n            this.upperBound = this.dictRange[1];\n            for (this.dictIndex = i = this.lowerBound; this.lowerBound <= this.upperBound ? i < this.upperBound : i > this.upperBound; this.dictIndex = this.lowerBound <= this.upperBound ? i += 1 : i -= 1) {\n              finalDict.push(String.fromCharCode(this.dictIndex));\n            }\n          });\n        }\n        if (shuffle) {\n          const PROBABILITY = 0.5;\n          finalDict = finalDict.sort(() => Math.random() - PROBABILITY);\n        }\n        this.dict = finalDict;\n        this.dictLength = this.dict.length;\n        this.counter = 0;\n      };\n      this.seq = () => {\n        return this.sequentialUUID();\n      };\n      this.sequentialUUID = () => {\n        let counterDiv;\n        let counterRem;\n        let id = \"\";\n        counterDiv = this.counter;\n        do {\n          counterRem = counterDiv % this.dictLength;\n          counterDiv = Math.trunc(counterDiv / this.dictLength);\n          id += this.dict[counterRem];\n        } while (counterDiv !== 0);\n        this.counter += 1;\n        return id;\n      };\n      this.randomUUID = (uuidLength = this.uuidLength || DEFAULT_UUID_LENGTH) => {\n        let id;\n        let randomPartIdx;\n        let j;\n        if (uuidLength === null || typeof uuidLength === \"undefined\" || uuidLength < 1) {\n          throw new Error(\"Invalid UUID Length Provided\");\n        }\n        const isPositive = uuidLength >= 0;\n        id = \"\";\n        for (j = 0; j < uuidLength; j += 1) {\n          randomPartIdx = parseInt((Math.random() * this.dictLength).toFixed(0), 10) % this.dictLength;\n          id += this.dict[randomPartIdx];\n        }\n        return id;\n      };\n      this.availableUUIDs = (uuidLength = this.uuidLength) => {\n        return parseFloat(Math.pow([...new Set(this.dict)].length, uuidLength).toFixed(0));\n      };\n      this.approxMaxBeforeCollision = (rounds = this.availableUUIDs(this.uuidLength)) => {\n        return parseFloat(Math.sqrt(Math.PI / 2 * rounds).toFixed(20));\n      };\n      this.collisionProbability = (rounds = this.availableUUIDs(this.uuidLength), uuidLength = this.uuidLength) => {\n        return parseFloat((this.approxMaxBeforeCollision(rounds) / this.availableUUIDs(uuidLength)).toFixed(20));\n      };\n      this.uniqueness = (rounds = this.availableUUIDs(this.uuidLength)) => {\n        const score = parseFloat((1 - this.approxMaxBeforeCollision(rounds) / rounds).toFixed(20));\n        return score > 1 ? 1 : score < 0 ? 0 : score;\n      };\n      this.getVersion = () => {\n        return this.version;\n      };\n      this.stamp = (finalLength) => {\n        if (typeof finalLength !== \"number\" || finalLength < 10) {\n          throw new Error(\"Param finalLength must be number greater than 10\");\n        }\n        const hexStamp = Math.floor(+new Date() / 1e3).toString(16);\n        const idLength = finalLength - 9;\n        const rndIdx = Math.round(Math.random() * (idLength > 15 ? 15 : idLength));\n        const id = this.randomUUID(idLength);\n        return `${id.substr(0, rndIdx)}${hexStamp}${id.substr(rndIdx)}${rndIdx.toString(16)}`;\n      };\n      this.parseStamp = (stamp) => {\n        if (stamp.length < 10) {\n          throw new Error(\"Stamp length invalid\");\n        }\n        const rndIdx = parseInt(stamp.substr(stamp.length - 1, 1), 16);\n        return new Date(parseInt(stamp.substr(rndIdx, 8), 16) * 1e3);\n      };\n      const options = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS), argOptions);\n      this.counter = 0;\n      this.debug = false;\n      this.dict = [];\n      this.version = version;\n      const {\n        dictionary,\n        shuffle,\n        length\n      } = options;\n      this.uuidLength = length;\n      this.setDictionary(dictionary, shuffle);\n      this.debug = options.debug;\n      this.log(this.dict);\n      this.log(`Generator instantiated with Dictionary Size ${this.dictLength}`);\n      return new Proxy(this, {\n        apply: (target, that, args) => this.randomUUID(...args)\n      });\n    }\n  };\n  var ShortUniqueId = _ShortUniqueId;\n  ShortUniqueId.default = _ShortUniqueId;\n  return src_exports;\n})();\n//# sourceMappingURL=short-unique-id.js.map\n true&&(module.exports=ShortUniqueId.default),'undefined'!=typeof window&&(ShortUniqueId=ShortUniqueId.default);\n\n//# sourceURL=webpack://WebRTCMetrics/./node_modules/short-unique-id/dist/short-unique-id.js?");

/***/ }),

/***/ "./src/collector.js":
/*!**************************!*\
  !*** ./src/collector.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Collector)\n/* harmony export */ });\n/* harmony import */ var _exporter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exporter */ \"./src/exporter.js\");\n/* harmony import */ var _extractor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extractor */ \"./src/extractor.js\");\n/* harmony import */ var _utils_score__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/score */ \"./src/utils/score.js\");\n/* harmony import */ var _utils_models__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/models */ \"./src/utils/models.js\");\n/* harmony import */ var _utils_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/helper */ \"./src/utils/helper.js\");\n/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/log */ \"./src/utils/log.js\");\n/* harmony import */ var _live__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./live */ \"./src/live.js\");\n\n\n\n\n\n\n\n\nclass Collector {\n  constructor(cfg, refProbeId) {\n    this._callbacks = {\n      onreport: null,\n      onticket: null,\n    };\n\n    this._id = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.createCollectorId)();\n    this._moduleName = this._id;\n    this._probeId = refProbeId;\n    this._config = cfg;\n    this._exporter = new _exporter__WEBPACK_IMPORTED_MODULE_0__[\"default\"](cfg);\n    this._state = _utils_models__WEBPACK_IMPORTED_MODULE_3__.COLLECTOR_STATE.IDLE;\n\n    this.deviceChanged = () => this._onDeviceChange();\n    this.connectionStateChange = () => this._onConnectionStateChange();\n    this.iceConnectionStateChange = () => this._onIceConnectionStateChange();\n    this.iceGatheringStateChange = () => this._onIceGatheringStateChange();\n    this.track = (e) => this._onTrack(e);\n    this.negotiationNeeded = () => this._onNegotiationNeeded();\n\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.info)(this._moduleName, `new collector created for probe ${this._probeId}`);\n  }\n\n  analyze(\n    stats,\n    oldStats,\n    previousReport,\n    beforeLastReport,\n    referenceReport,\n    _refPC,\n  ) {\n    const getDefaultSSRCMetric = (kind, reportType) => {\n      if (kind === _utils_models__WEBPACK_IMPORTED_MODULE_3__.VALUE.AUDIO) {\n        if (reportType === _utils_models__WEBPACK_IMPORTED_MODULE_3__.TYPE.INBOUND_RTP) {\n          return { ..._utils_models__WEBPACK_IMPORTED_MODULE_3__.defaultAudioMetricIn };\n        }\n        return { ..._utils_models__WEBPACK_IMPORTED_MODULE_3__.defaultAudioMetricOut };\n      }\n\n      if (reportType === _utils_models__WEBPACK_IMPORTED_MODULE_3__.TYPE.INBOUND_RTP) {\n        return { ..._utils_models__WEBPACK_IMPORTED_MODULE_3__.defaultVideoMetricIn };\n      }\n      return { ..._utils_models__WEBPACK_IMPORTED_MODULE_3__.defaultVideoMetricOut };\n    };\n\n    // Get previous report without any modifications\n    const report = (0,_utils_models__WEBPACK_IMPORTED_MODULE_3__.getDefaultMetric)(previousReport);\n\n    let timestamp = null;\n    stats.forEach((stat) => {\n      if (!timestamp && stat.timestamp) {\n        timestamp = stat.timestamp;\n      }\n      const values = (0,_extractor__WEBPACK_IMPORTED_MODULE_1__.extract)(\n        stat,\n        report,\n        report.pname,\n        referenceReport,\n        stats,\n        oldStats,\n        _refPC,\n      );\n      values.forEach((data) => {\n        if (\"internal\" in data) {\n          const events = (0,_live__WEBPACK_IMPORTED_MODULE_6__.doLiveTreatment)(data, previousReport, values);\n          events.forEach((event) => this.addCustomEvent(event));\n        }\n        if (data.value && data.type) {\n          if (data.ssrc) {\n            let ssrcReport = report[data.type][data.ssrc];\n            if (!ssrcReport) {\n              ssrcReport = getDefaultSSRCMetric(data.type, stat.type);\n              ssrcReport.ssrc = data.ssrc;\n              report[data.type][data.ssrc] = ssrcReport;\n            }\n            Object.keys(data.value).forEach((key) => {\n              ssrcReport[key] = data.value[key];\n            });\n          } else {\n            Object.keys(data.value).forEach((key) => {\n              report[data.type][key] = data.value[key];\n            });\n          }\n        }\n      });\n\n      // Extract passthrough fields\n      const passthrough = (0,_extractor__WEBPACK_IMPORTED_MODULE_1__.extractPassthroughFields)(\n        stat,\n        this._config.passthrough,\n      );\n      Object.keys(passthrough).forEach((key) => {\n        if (!report.passthrough[key]) {\n          report.passthrough[key] = {};\n        }\n        report.passthrough[key] = {\n          ...report.passthrough[key],\n          ...passthrough[key],\n        };\n      });\n    });\n    report.pname = this._config.pname;\n    report.call_id = this._config.cid;\n    report.user_id = this._config.uid;\n    report.count = previousReport ? previousReport.count + 1 : 1;\n    report.timestamp = timestamp;\n    Object.keys(report[_utils_models__WEBPACK_IMPORTED_MODULE_3__.VALUE.AUDIO]).forEach((key) => {\n      const ssrcReport = report[_utils_models__WEBPACK_IMPORTED_MODULE_3__.VALUE.AUDIO][key];\n      ssrcReport[\n        ssrcReport.direction === _utils_models__WEBPACK_IMPORTED_MODULE_3__.DIRECTION.INBOUND\n          ? \"mos_emodel_in\"\n          : \"mos_model_out\"\n      ] = (0,_utils_score__WEBPACK_IMPORTED_MODULE_2__.computeEModelMOS)(\n        report,\n        _utils_models__WEBPACK_IMPORTED_MODULE_3__.VALUE.AUDIO,\n        previousReport,\n        beforeLastReport,\n        ssrcReport.ssrc,\n        ssrcReport.direction,\n        3,\n      );\n      ssrcReport[\n        ssrcReport.direction === _utils_models__WEBPACK_IMPORTED_MODULE_3__.DIRECTION.INBOUND ? \"mos_in\" : \"mos_out\"\n      ] = (0,_utils_score__WEBPACK_IMPORTED_MODULE_2__.computeMOS)(\n        report,\n        _utils_models__WEBPACK_IMPORTED_MODULE_3__.VALUE.AUDIO,\n        previousReport,\n        beforeLastReport,\n        ssrcReport.ssrc,\n        ssrcReport.direction,\n        3,\n      );\n      ssrcReport[\n        ssrcReport.direction === _utils_models__WEBPACK_IMPORTED_MODULE_3__.DIRECTION.INBOUND\n          ? \"mos_fullband_in\"\n          : \"mos_fullband_out\"\n      ] = (0,_utils_score__WEBPACK_IMPORTED_MODULE_2__.computeFullEModelScore)(\n        report,\n        _utils_models__WEBPACK_IMPORTED_MODULE_3__.VALUE.AUDIO,\n        previousReport,\n        beforeLastReport,\n        ssrcReport.ssrc,\n        ssrcReport.direction,\n        3,\n      );\n    });\n    return report;\n  }\n\n  async takeReferenceStats() {\n    return new Promise((resolve, reject) => {\n      const preWaitTime = Date.now();\n      setTimeout(async () => {\n        try {\n          const waitTime = Date.now() - preWaitTime;\n          const preTime = Date.now();\n          const reports = await this._config.pc.getStats();\n          const referenceReport = this.analyze(\n            reports,\n            null,\n            null,\n            null,\n            null,\n            this._config.pc,\n          );\n          const postTime = Date.now();\n          referenceReport.experimental.time_to_measure_ms = postTime - preTime;\n          referenceReport.experimental.time_to_wait_ms = waitTime;\n          this._exporter.saveReferenceReport(referenceReport);\n          (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.debug)(\n            this._moduleName,\n            `got reference report for probe ${this._probeId}`,\n          );\n          resolve();\n        } catch (err) {\n          reject(err);\n        }\n      }, this._config.startAfter);\n    });\n  }\n\n  async collectStats() {\n    try {\n      if (this._state !== _utils_models__WEBPACK_IMPORTED_MODULE_3__.COLLECTOR_STATE.RUNNING || !this._config.pc) {\n        (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.debug)(\n          this._moduleName,\n          `report discarded (too late) for probe ${this._probeId}`,\n        );\n        return null;\n      }\n\n      const preTime = Date.now();\n      const reports = await this._config.pc.getStats();\n      const report = this.analyze(\n        reports,\n        this._oldReports,\n        this._exporter.getLastReport(),\n        this._exporter.getBeforeLastReport(),\n        this._exporter.getReferenceReport(),\n        this._config.pc,\n      );\n      this._oldReports = reports;\n      const postTime = Date.now();\n      report.experimental.time_to_measure_ms = postTime - preTime;\n      this._exporter.addReport(report);\n      (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.debug)(\n        this._moduleName,\n        `got report for probe ${this._probeId}#${\n          this._exporter.getReportsNumber() + 1\n        }`,\n      );\n      this.fireOnReport(report);\n      return report;\n    } catch (err) {\n      (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.error)(this._moduleName, `got error ${err}`);\n      return null;\n    }\n  }\n\n  async start() {\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.debug)(this._moduleName, \"starting\");\n    this._oldReports = null;\n    this._exporter.reset();\n    await this.registerToPCEvents();\n    this.state = _utils_models__WEBPACK_IMPORTED_MODULE_3__.COLLECTOR_STATE.RUNNING;\n    this._exporter.start();\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.debug)(this._moduleName, \"started\");\n  }\n\n  async mute() {\n    this.state = _utils_models__WEBPACK_IMPORTED_MODULE_3__.COLLECTOR_STATE.MUTED;\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.debug)(this._moduleName, \"muted\");\n  }\n\n  async unmute() {\n    this.state = _utils_models__WEBPACK_IMPORTED_MODULE_3__.COLLECTOR_STATE.RUNNING;\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.debug)(this._moduleName, \"unmuted\");\n  }\n\n  async stop(forced) {\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.debug)(this._moduleName, `stopping${forced ? \" by watchdog\" : \"\"}...`);\n    this._exporter.stop();\n    this.unregisterToPCEvents();\n    this.state = _utils_models__WEBPACK_IMPORTED_MODULE_3__.COLLECTOR_STATE.IDLE;\n\n    if (this._config.ticket) {\n      const ticket = this._exporter.generateTicket();\n      this.fireOnTicket(ticket);\n    }\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.debug)(this._moduleName, \"stopped\");\n  }\n\n  registerCallback(name, callback, context) {\n    if (name in this._callbacks) {\n      this._callbacks[name] = {\n        callback,\n        context,\n      };\n      (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.debug)(this._moduleName, `registered callback '${name}'`);\n    } else {\n      (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.error)(\n        this._moduleName,\n        `can't register callback for '${name}' - not found`,\n      );\n    }\n  }\n\n  unregisterCallback(name) {\n    if (name in this._callbacks) {\n      this._callbacks[name] = null;\n      delete this._callbacks[name];\n      (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.debug)(this._moduleName, `unregistered callback '${name}'`);\n    } else {\n      (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.error)(\n        this._moduleName,\n        `can't unregister callback for '${name}' - not found`,\n      );\n    }\n  }\n\n  fireOnReport(report) {\n    if (this._callbacks.onreport) {\n      (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.call)(\n        this._callbacks.onreport.callback,\n        this._callbacks.onreport.context,\n        report,\n      );\n    }\n  }\n\n  fireOnTicket(ticket) {\n    if (this._callbacks.onticket) {\n      (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.call)(\n        this._callbacks.onticket.callback,\n        this._callbacks.onticket.context,\n        ticket,\n      );\n    }\n  }\n\n  updateConfig(config) {\n    this._config = config;\n    this._exporter.updateConfig(config);\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  set state(newState) {\n    this._state = newState;\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.debug)(this._moduleName, `state changed to ${newState}`);\n  }\n\n  addCustomEvent(event) {\n    this._exporter.addCustomEvent(event);\n  }\n\n  async _onDeviceChange() {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      this.addCustomEvent({\n        at: new Date().toJSON(),\n        ended: null,\n        category: \"device\",\n        name: \"device-change\",\n        ssrc: null,\n        details: {\n          message: \"One device (at least) has been plugged or unplugged\",\n          direction: null,\n          kind: null,\n          value: devices.length,\n          value_old: null,\n        },\n      });\n      // eslint-disable-next-line no-empty\n    } catch (err) {\n      (0,_utils_log__WEBPACK_IMPORTED_MODULE_5__.error)(this._moduleName, \"can't get devices\");\n    }\n  }\n\n  _onIceConnectionStateChange() {\n    const { pc } = this._config;\n    const value = pc.iceConnectionState;\n        this.addCustomEvent({\n          at: new Date().toJSON(),\n          ended: null,\n          category: \"signal\",\n          name: \"ice-change\",\n          ssrc: null,\n          details: {\n            message: `The ICE connection state has changed to ${value}`,\n            direction: null,\n            kind: null,\n            value,\n            value_old: null,\n          },\n        });\n  }\n\n  _onConnectionStateChange() {\n    const { pc } = this._config;\n    const value = pc.connectionState;\n        this.addCustomEvent({\n          at: new Date().toJSON(),\n          ended: null,\n          category: \"signal\",\n          name: \"connection-change\",\n          ssrc: null,\n          details: {\n            message: `The connection state has changed to ${value}`,\n            direction: null,\n            kind: null,\n            value,\n            value_old: null,\n          },\n        });\n  }\n\n  _onIceGatheringStateChange() {\n    const { pc } = this._config;\n    const value = pc.iceGatheringState;\n        this.addCustomEvent({\n          at: new Date().toJSON(),\n          ended: null,\n          category: \"signal\",\n          name: \"gathering-change\",\n          ssrc: null,\n          details: {\n            message: `The ICE gathering state has changed to ${value}`,\n            direction: null,\n            kind: null,\n            value,\n            value_old: null,\n          },\n        });\n  }\n\n  _onTrack(e) {\n        this.addCustomEvent({\n          at: new Date().toJSON(),\n          ended: null,\n          category: \"signal\",\n          name: \"track-received\",\n          ssrc: null,\n          details: {\n            message: `A new inbound ${e.track.id} stream has been started`,\n            direction: \"inbound\",\n            kind: e.track.kind,\n            value: e.track.label,\n            value_old: null,\n          },\n        });\n  }\n\n  _onNegotiationNeeded() {\n        this.addCustomEvent({\n          at: new Date().toJSON(),\n          ended: null,\n          category: \"signal\",\n          name: \"ice-negotiation\",\n          ssrc: null,\n          details: {\n            message: \"A negotiation is required\",\n            direction: null,\n            kind: null,\n            value: \"negotiation-needed\",\n            value_old: null,\n          },\n        });\n  }\n\n  async registerToPCEvents() {\n    const { pc } = this._config;\n    navigator.mediaDevices.addEventListener(\"devicechange\", this.deviceChanged);\n    if (pc) {\n      pc.addEventListener(\"iceconnectionstatechange\", this.iceConnectionStateChange);\n      pc.addEventListener(\"connectionstatechange\", this.connectionStateChange);\n      pc.addEventListener(\"icegatheringstatechange\", this.iceGatheringStateChange);\n      pc.addEventListener(\"track\", this.track);\n      pc.addEventListener(\"negotiationneeded\", this.negotiationNeeded);\n    }\n  }\n\n  unregisterToPCEvents() {\n    const { pc } = this._config;\n    navigator.mediaDevices.removeEventListener(\"devicechange\", this.deviceChanged);\n    if (pc) {\n      pc.removeEventListener(\"iceconnectionstatechange\", this.iceConnectionStateChange);\n      pc.removeEventListener(\"connectionstatechange\", this.connectionStateChange);\n      pc.removeEventListener(\"icegatheringstatechange\", this.iceGatheringStateChange);\n      pc.removeEventListener(\"track\", this.track);\n      pc.removeEventListener(\"negotiationneeded\", this.negotiationNeeded);\n    }\n  }\n\n  getTicket() {\n    return this._exporter && this._exporter.generateTicket();\n  }\n}\n\n\n//# sourceURL=webpack://WebRTCMetrics/./src/collector.js?");

/***/ }),

/***/ "./src/engine.js":
/*!***********************!*\
  !*** ./src/engine.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ProbesEngine)\n/* harmony export */ });\n/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/log */ \"./src/utils/log.js\");\n/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/config */ \"./src/utils/config.js\");\n/* harmony import */ var _probe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./probe */ \"./src/probe.js\");\n/* harmony import */ var _utils_models__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/models */ \"./src/utils/models.js\");\n/* harmony import */ var _utils_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/helper */ \"./src/utils/helper.js\");\n\n\n\n\n\n\nconst moduleName = \"engine      \";\n\nclass ProbesEngine {\n  constructor(cfg) {\n    this._config = cfg;\n    this._probes = [];\n    this._startedTime = null;\n    this._callbacks = {\n      onresult: null,\n    };\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.info)(moduleName, `configured for probing every ${this._config.refreshEvery}ms`);\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.info)(moduleName, `configured for starting after ${this._config.startAfter}ms`);\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.info)(moduleName, `${(!this._config.stopAfter || this._config.stopAfter !== -1) ? `configured for stopped after ${this._config.stopAfter}ms` : \"configured for never stopped\"}`);\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.debug)(moduleName, \"engine initialized\");\n  }\n\n  get probes() {\n    return this._probes;\n  }\n\n  get isRunning() {\n    return this._probes.some((probe) => (probe.isRunning));\n  }\n\n  get isIdle() {\n    return this._probes.every((probe) => (probe.isIdle));\n  }\n\n  addNewProbe(peerConnection, options) {\n    if (!peerConnection) {\n      throw new Error(\"undefined peer connection\");\n    }\n    const probeConfig = (0,_utils_config__WEBPACK_IMPORTED_MODULE_1__.getConfig)(peerConnection, options, this._config);\n    const probe = new _probe__WEBPACK_IMPORTED_MODULE_2__[\"default\"](probeConfig);\n    this._probes.push(probe);\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.debug)(moduleName, `${this._probes.length} probes registered`);\n    return probe;\n  }\n\n  removeExistingProbe(probe) {\n    if (!probe) {\n      throw new Error(\"undefined probe\");\n    }\n    if (probe.state === _utils_models__WEBPACK_IMPORTED_MODULE_3__.COLLECTOR_STATE.RUNNING) {\n      probe.stop();\n    }\n    this._probes = this._probes.filter((existingProbe) => (probe.id !== existingProbe.id));\n  }\n\n  async start() {\n    const startProbes = () => {\n      this._probes.forEach((probe) => probe.start());\n    };\n\n    const takeReferenceStat = async () => (\n      Promise.all(this._probes.map((probe) => (probe.takeReferenceStats())))\n    );\n\n    const shouldCollectStats = () => {\n      if (this.isIdle) {\n        // don't collect if there is no running probes\n        return false;\n      }\n      if (!this._config.stopAfter || this._config.stopAfter < 0) {\n        // always collect if stopAfter has not been set\n        return true;\n      }\n      // Else check expiration\n      return (Date.now() < this._startedTime + this._config.stopAfter);\n    };\n\n    const collectStats = async () => {\n      const globalReport = (0,_utils_models__WEBPACK_IMPORTED_MODULE_3__.getDefaultGlobalMetric)();\n      const runningProbes = this._probes.filter((probe) => (probe.isRunning));\n      for (const probe of runningProbes) {\n        const report = await probe.collectStats();\n        if (report) {\n          globalReport.probes.push(report);\n        }\n        (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.debug)(moduleName, `got probe ${probe.id}`);\n        await (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.timeout)(0);\n      }\n\n      // Compute total measure time\n      globalReport.delta_time_to_measure_probes_ms = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.sumValuesOfReports)(globalReport.probes, \"experimental\", \"time_to_measure_ms\");\n      globalReport.delta_KBytes_in = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.sumValuesOfReports)(globalReport.probes, \"data\", \"delta_KBytes_in\");\n      globalReport.delta_KBytes_out = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.sumValuesOfReports)(globalReport.probes, \"data\", \"delta_KBytes_out\");\n      globalReport.delta_kbs_in = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.sumValuesOfReports)(globalReport.probes, \"data\", \"delta_kbs_in\");\n      globalReport.delta_kbs_out = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.sumValuesOfReports)(globalReport.probes, \"data\", \"delta_kbs_out\");\n      globalReport.total_time_decoded_in = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.sumValuesOfReports)(globalReport.probes, \"video\", \"total_time_decoded_in\");\n      globalReport.total_time_encoded_out = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.sumValuesOfReports)(globalReport.probes, \"video\", \"total_time_encoded_out\");\n      return globalReport;\n    };\n\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.debug)(moduleName, \"starting to collect\");\n    startProbes();\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.debug)(moduleName, \"generating reference reports...\");\n    await takeReferenceStat();\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.debug)(moduleName, \"reference reports generated\");\n    this._startedTime = Date.now();\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.debug)(moduleName, `wait ${this._config.refreshEvery}ms before collecting`);\n    await (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.timeout)(this._config.refreshEvery);\n    while (shouldCollectStats()) {\n      (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.debug)(moduleName, \"collecting...\");\n      const preTime = Date.now();\n      const globalReport = await collectStats();\n      const postTime = Date.now();\n      globalReport.delta_time_consumed_to_measure_ms = postTime - preTime;\n      this.fireOnReports(globalReport);\n      (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.debug)(moduleName, \"collected\");\n      (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.debug)(moduleName, `wait ${this._config.refreshEvery}ms before collecting`);\n      await (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.timeout)(this._config.refreshEvery);\n    }\n\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.debug)(moduleName, \"reaching end of the collecting period...\");\n\n    if (this.isRunning) {\n      setTimeout(() => {\n        this.stop();\n      }, 0);\n    }\n  }\n\n  stop(forced) {\n    const stopProbes = (manual) => {\n      this._probes.forEach((probe) => {\n        probe.stop(manual);\n      });\n    };\n\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.info)(moduleName, \"stop collecting\");\n    stopProbes(forced);\n  }\n\n  registerCallback(name, callback, context) {\n    if (name in this._callbacks) {\n      this._callbacks[name] = { callback, context };\n      (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.debug)(moduleName, `registered callback '${name}'`);\n    } else {\n      (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.error)(moduleName, `can't register callback for '${name}' - not found`);\n    }\n  }\n\n  unregisterCallback(name) {\n    if (name in this._callbacks) {\n      this._callbacks[name] = null;\n      delete this._callbacks[name];\n      (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.debug)(this._moduleName, `unregistered callback '${name}'`);\n    } else {\n      (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.error)(this._moduleName, `can't unregister callback for '${name}' - not found`);\n    }\n  }\n\n  fireOnReports(report) {\n    if (this._callbacks.onresult && report.probes.length > 0) {\n      (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.call)(this._callbacks.onresult.callback, this._callbacks.onresult.context, report);\n    }\n  }\n}\n\n\n//# sourceURL=webpack://WebRTCMetrics/./src/engine.js?");

/***/ }),

/***/ "./src/exporter.js":
/*!*************************!*\
  !*** ./src/exporter.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Exporter)\n/* harmony export */ });\n/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/log */ \"./src/utils/log.js\");\n/* harmony import */ var _utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/helper */ \"./src/utils/helper.js\");\n/* harmony import */ var _utils_models__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/models */ \"./src/utils/models.js\");\n\n\n\n\nconst moduleName = \"exporter    \";\n\nconst VERSION_EXPORTER = \"2.0\";\n\nconst averageRTT = (reports, kind, ssrc, forInbound = false) => {\n  if (!reports || reports.length === 0) {\n    return 0;\n  }\n\n  const lastReport = reports[reports.length - 1];\n  if (!lastReport) {\n    return 0;\n  }\n\n  const ssrcData = lastReport[kind][ssrc];\n  if (ssrcData) {\n    const totalRTT = forInbound ? ssrcData.total_rtt_ms_in : ssrcData.total_rtt_ms_out;\n    const totalMeasurements = forInbound ? ssrcData.total_rtt_measure_in : ssrcData.total_rtt_measure_out;\n\n    if (!totalMeasurements || !totalRTT) {\n      return (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(reports, kind, forInbound ? \"delta_rtt_ms_in\" : \"delta_rtt_ms_out\", false, ssrc);\n    }\n\n    return Number(totalRTT / totalMeasurements);\n  }\n  return null;\n};\n\nconst limitationsPercent = (reports, kind, ssrc) => {\n  const defaultValue = {\n    other: 0,\n    cpu: 0,\n    bandwidth: 0,\n    none: 100,\n  };\n\n  if (!reports || reports.length === 0) {\n    return defaultValue;\n  }\n\n  const lastReport = reports[reports.length - 1];\n  const ssrcData = lastReport[kind][ssrc];\n\n  if (!ssrcData) {\n    return defaultValue;\n  }\n\n  if (!(\"limitation_out\" in ssrcData) || !(\"durations\" in ssrcData.limitation_out)) {\n    return defaultValue;\n  }\n\n  // FF: No quality limitations\n  if (!ssrcData.limitation_out.durations) {\n    return defaultValue;\n  }\n\n  const {\n    other,\n    bandwidth,\n    cpu,\n    none,\n  } = ssrcData.limitation_out.durations;\n\n  const totalDuration = Number(other) + Number(bandwidth) + Number(cpu) + Number(none);\n\n  return {\n    other: +((other / totalDuration) * 100).toFixed(2),\n    cpu: +((cpu / totalDuration) * 100).toFixed(2),\n    bandwidth: +((bandwidth / totalDuration) * 100).toFixed(2),\n    none: +((none / totalDuration) * 100).toFixed(2),\n  };\n};\n\nconst averageRTTConnectivity = (reports, kind) => {\n  if (!reports || reports.length === 0) {\n    return 0;\n  }\n\n  const lastReport = reports[reports.length - 1];\n  if (!lastReport) {\n    return 0;\n  }\n  const totalRTT = lastReport[kind].total_rtt_connectivity_ms;\n  const totalMeasurements = lastReport[kind].total_rtt_connectivity_measure;\n\n  if (!totalMeasurements || !totalRTT) {\n    return (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(\n      reports,\n      kind,\n      \"delta_rtt_connectivity_ms\",\n    );\n  }\n\n  return Number(totalRTT / totalMeasurements);\n};\n\nconst getPath = (reports) => {\n  const localCandidateType = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n    reports,\n    \"network\",\n    \"local_candidate_type\",\n  );\n\n  if (localCandidateType !== \"relay\") {\n    const localCandidateProtocol = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n      reports,\n      \"network\",\n      \"local_candidate_protocol\",\n    );\n    return `direct/${localCandidateProtocol}`;\n  }\n\n  const localCandidateRelayProtocol = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n    reports,\n    \"network\",\n    \"local_candidate_relay_protocol\",\n  );\n  return `turn/${localCandidateRelayProtocol}`;\n};\n\nconst getRemotePath = (reports) => {\n  const localCandidateType = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n    reports,\n    \"network\",\n    \"remote_candidate_type\",\n  );\n  const localCandidateProtocol = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n    reports,\n    \"network\",\n    \"remote_candidate_protocol\",\n  );\n\n  if (localCandidateType !== \"relay\") {\n    return `direct/${localCandidateProtocol}`;\n  }\n\n  return `turn/${localCandidateProtocol}`;\n};\n\nclass Exporter {\n  constructor(cfg) {\n    this._start = null;\n    this._end = null;\n    this._cfg = cfg;\n    this._referenceReport = null;\n    this._reports = [];\n    this._events = [];\n  }\n\n  start() {\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.trace)(moduleName, \"start() - start exporter...\");\n    const date = new Date();\n    this._start = date.toJSON();\n    return date;\n  }\n\n  stop() {\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.trace)(moduleName, \"stop() - stop exporter...\");\n    const date = new Date();\n    this._end = date.toJSON();\n    return date;\n  }\n\n  saveReferenceReport(report) {\n    this._referenceReport = report;\n  }\n\n  getReferenceReport() {\n    return this._referenceReport;\n  }\n\n  addReport(report) {\n    if (this._cfg.ticket) {\n      (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.debug)(\n        moduleName,\n        `addReport() - add report to exporter at ${report.timestamp}`,\n      );\n      this._reports.push(report);\n    }\n  }\n\n  addCustomEvent(event) {\n    this._events.push(event);\n  }\n\n  reset() {\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.trace)(moduleName, \"resetReports() - reset reports\");\n    this._reports = [];\n    this._referenceReport = null;\n    this._start = null;\n    this._end = null;\n  }\n\n  generateTicket() {\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.debug)(moduleName, \"ticket() - generate ticket\");\n\n    const audioPacketsLost = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n      this._reports,\n      \"audio\",\n      \"total_packets_lost_in\",\n    );\n    const audioPacketsReceived = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n      this._reports,\n      \"audio\",\n      \"total_packets_in\",\n    );\n    const videoPacketsLost = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n      this._reports,\n      \"video\",\n      \"total_packets_lost_in\",\n    );\n    const videoPacketsReceived = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n      this._reports,\n      \"video\",\n      \"total_packets_in\",\n    );\n\n    const ssrcExporter = {};\n\n    const lastReport = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getLastReport)(this._reports);\n    if (lastReport) {\n      Object.keys(lastReport[_utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO]).forEach((ssrc) => {\n        const ssrcAudio = lastReport[_utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO][ssrc];\n        ssrcExporter[ssrcAudio.ssrc] = {\n          type: _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n          direction: ssrcAudio.direction,\n        };\n        if (ssrcAudio.direction === _utils_models__WEBPACK_IMPORTED_MODULE_2__.DIRECTION.INBOUND) {\n          const jitter = {\n            avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_jitter_ms_in\",\n              false,\n              ssrc,\n            ),\n            min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_jitter_ms_in\",\n              ssrc,\n            ),\n            max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_jitter_ms_in\",\n              ssrc,\n            ),\n            volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_jitter_ms_in\",\n              ssrc,\n            ),\n            values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"delta_jitter_ms_in\", ssrc),\n            _unit: {\n              avg: \"ms\",\n              min: \"ms\",\n              max: \"ms\",\n              volatility: \"percent\",\n            },\n          };\n          const bitrate = {\n            avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_kbs_in\",\n              false,\n              ssrc,\n            ),\n            min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_kbs_in\",\n              ssrc,\n            ),\n            max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_kbs_in\",\n              ssrc,\n            ),\n            volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_kbs_in\",\n              ssrc,\n            ),\n            values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"delta_kbs_in\", ssrc),\n            _unit: {\n              avg: \"kbs\",\n              min: \"kbs\",\n              max: \"kbs\",\n              volatility: \"percent\",\n            },\n          };\n          const traffic = {\n            avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_KBytes_in\",\n              false,\n              ssrc,\n            ),\n            min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_KBytes_in\",\n              ssrc,\n            ),\n            max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_KBytes_in\",\n              ssrc,\n            ),\n            volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_KBytes_in\",\n              ssrc,\n            ),\n            values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"delta_KBytes_in\", ssrc),\n            _unit: {\n              avg: \"KB\",\n              min: \"KB\",\n              max: \"KB\",\n              volatility: \"percent\",\n            },\n          };\n          const mos = {\n            emodel: {\n              avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"mos_fullband_in\", false, ssrc),\n              min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"mos_fullband_in\", ssrc),\n              max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"mos_fullband_in\", ssrc),\n              volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n                \"mos_fullband_in\",\n                ssrc,\n              ),\n              values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"mos_fullband_in\", ssrc),\n            },\n            effective: {\n              avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"mos_in\", false, ssrc),\n              min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"mos_in\", ssrc),\n              max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"mos_in\", ssrc),\n              volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n                \"mos_in\",\n                ssrc,\n              ),\n              values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"mos_in\", ssrc),\n            },\n            _unit: {\n              avg: \"number (1-5)\",\n              min: \"number (1-5)\",\n              max: \"number (1-5)\",\n              volatility: \"percent\",\n            },\n          };\n          const packetsLost = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n            this._reports,\n            _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n            \"total_packets_lost_in\",\n            ssrc,\n          );\n          const packetsReceived = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n            this._reports,\n            _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n            \"total_packets_in\",\n            ssrc,\n          );\n          const loss = {\n            lost: packetsLost,\n            avg: Math.round(\n              ((packetsLost /\n                (packetsLost + packetsReceived)) *\n                100 || 0) * 100,\n            ) / 100,\n            values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"delta_packets_lost_in\", ssrc),\n            _unit: {\n              avg: \"percent\",\n              lost: \"number\",\n            },\n          };\n          const rtt = {\n            avg: averageRTT(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, ssrc, true),\n            min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"delta_rtt_ms_in\", ssrc),\n            max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"delta_rtt_ms_in\", ssrc),\n            volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_rtt_ms_in\",\n              ssrc,\n            ),\n            values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"delta_rtt_ms_in\", ssrc),\n            _unit: {\n              avg: \"ms\",\n              min: \"ms\",\n              max: \"ms\",\n              volatility: \"percent\",\n            },\n          };\n          ssrcExporter[ssrc].jitter = jitter;\n          ssrcExporter[ssrc].rtt = rtt;\n          ssrcExporter[ssrc].mos = mos;\n          ssrcExporter[ssrc].traffic = traffic;\n          ssrcExporter[ssrc].bitrate = bitrate;\n          ssrcExporter[ssrc].loss = loss;\n        } else {\n          const jitter = {\n            avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_jitter_ms_out\",\n              false,\n              ssrc,\n            ),\n            min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_jitter_ms_out\",\n              ssrc,\n            ),\n            max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_jitter_ms_out\",\n              ssrc,\n            ),\n            volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_jitter_ms_out\",\n              ssrc,\n            ),\n            values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"delta_jitter_ms_out\", ssrc),\n            _unit: {\n              avg: \"ms\",\n              min: \"ms\",\n              max: \"ms\",\n              volatility: \"percent\",\n            },\n          };\n          const bitrate = {\n            avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_kbs_out\",\n              false,\n              ssrc,\n            ),\n            min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_kbs_out\",\n              ssrc,\n            ),\n            max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_kbs_out\",\n              ssrc,\n            ),\n            volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_kbs_out\",\n              ssrc,\n            ),\n            values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"delta_kbs_out\", ssrc),\n            _unit: {\n              avg: \"kbs\",\n              min: \"kbs\",\n              max: \"kbs\",\n              volatility: \"percent\",\n            },\n          };\n          const traffic = {\n            avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_KBytes_out\",\n              false,\n              ssrc,\n            ),\n            min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_KBytes_out\",\n              ssrc,\n            ),\n            max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_KBytes_out\",\n              ssrc,\n            ),\n            volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_KBytes_out\",\n              ssrc,\n            ),\n            values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"delta_KBytes_out\", ssrc),\n            _unit: {\n              avg: \"KB\",\n              min: \"KB\",\n              max: \"KB\",\n              bitrate: \"kbs\",\n              volatility: \"percent\",\n            },\n          };\n          const rtt = {\n            avg: averageRTT(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, ssrc),\n            min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"delta_rtt_ms_out\", ssrc),\n            max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"delta_rtt_ms_out\", ssrc),\n            volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n              \"delta_rtt_ms_out\",\n              ssrc,\n            ),\n            values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"delta_rtt_ms_out\", ssrc),\n            _unit: {\n              avg: \"ms\",\n              min: \"ms\",\n              max: \"ms\",\n              volatility: \"percent\",\n            },\n          };\n          const packetsLost = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n            this._reports,\n            _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n            \"total_packets_lost_out\",\n            ssrc,\n          );\n          const packetsReceived = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n            this._reports,\n            _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n            \"total_packets_out\",\n            ssrc,\n          );\n          const loss = {\n            lost: packetsLost,\n            avg: Math.round(\n              ((packetsLost /\n                (packetsLost + packetsReceived)) *\n                100 || 0) * 100,\n            ) / 100,\n            values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"delta_packets_lost_out\", ssrc),\n            _unit: {\n              avg: \"percent\",\n              lost: \"number\",\n            },\n          };\n          const mos = {\n            emodel: {\n              avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"mos_fullband_out\", false, ssrc),\n              min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"mos_fullband_out\", ssrc),\n              max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"mos_fullband_out\", ssrc),\n              volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n                \"mos_fullband_out\",\n                ssrc,\n              ),\n              values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"mos_fullband_out\", ssrc),\n            },\n            effective: {\n              avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"mos_out\", false, ssrc),\n              min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"mos_out\", ssrc),\n              max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"mos_out\", ssrc),\n              volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO,\n                \"mos_out\",\n                ssrc,\n              ),\n              values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.AUDIO, \"mos_out\", ssrc),\n            },\n            _unit: {\n              avg: \"number (1-5)\",\n              min: \"number (1-5)\",\n              max: \"number (1-5)\",\n              volatility: \"percent\",\n            },\n          };\n          ssrcExporter[ssrc].jitter = jitter;\n          ssrcExporter[ssrc].rtt = rtt;\n          ssrcExporter[ssrc].traffic = traffic;\n          ssrcExporter[ssrc].bitrate = bitrate;\n          ssrcExporter[ssrc].loss = loss;\n          ssrcExporter[ssrc].mos = mos;\n        }\n      });\n      Object.keys(lastReport[_utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO])\n        .forEach((ssrc) => {\n          const ssrcVideo = lastReport[_utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO][ssrc];\n          ssrcExporter[ssrc] = {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n            direction: ssrcVideo.direction,\n          };\n          if (ssrcVideo.direction === _utils_models__WEBPACK_IMPORTED_MODULE_2__.DIRECTION.INBOUND) {\n            const jitter = {\n              avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_jitter_ms_in\",\n                false,\n                ssrc,\n              ),\n              min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_jitter_ms_in\",\n                ssrc,\n              ),\n              max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_jitter_ms_in\",\n                ssrc,\n              ),\n              volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_jitter_ms_in\",\n                ssrc,\n              ),\n              values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO, \"delta_jitter_ms_in\", ssrc),\n              _unit: {\n                avg: \"ms\",\n                min: \"ms\",\n                max: \"ms\",\n                volatility: \"percent\",\n              },\n            };\n            const bitrate = {\n              avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_kbs_in\",\n                false,\n                ssrc,\n              ),\n              min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_kbs_in\",\n                ssrc,\n              ),\n              max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_kbs_in\",\n                ssrc,\n              ),\n              volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_kbs_in\",\n                ssrc,\n              ),\n              values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO, \"delta_kbs_in\", ssrc),\n              _unit: {\n                avg: \"kbs\",\n                min: \"kbs\",\n                max: \"kbs\",\n                volatility: \"percent\",\n              },\n            };\n            const traffic = {\n              avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_KBytes_in\",\n                false,\n                ssrc,\n              ),\n              min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_KBytes_in\",\n                ssrc,\n              ),\n              max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_KBytes_in\",\n                ssrc,\n              ),\n              volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_KBytes_in\",\n                ssrc,\n              ),\n              values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO, \"delta_KBytes_in\", ssrc),\n              _unit: {\n                avg: \"KB\",\n                min: \"KB\",\n                max: \"KB\",\n                volatility: \"percent\",\n              },\n            };\n            const packetsLost = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n              \"total_packets_lost_in\",\n              ssrc,\n            );\n            const packetsReceived = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n              \"total_packets_in\",\n              ssrc,\n            );\n            const loss = {\n              lost: packetsLost,\n              avg: Math.round(\n                ((packetsLost /\n                    (packetsLost + packetsReceived)) *\n                  100 || 0) * 100,\n              ) / 100,\n              values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO, \"delta_packets_lost_in\", ssrc),\n              _unit: {\n                avg: \"percent\",\n                lost: \"number\",\n              },\n            };\n            ssrcExporter[ssrc].jitter = jitter;\n            ssrcExporter[ssrc].traffic = traffic;\n            ssrcExporter[ssrc].bitrate = bitrate;\n            ssrcExporter[ssrc].loss = loss;\n          } else {\n            const jitter = {\n              avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_jitter_ms_out\",\n                false,\n                ssrc,\n              ),\n              min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_jitter_ms_out\",\n                ssrc,\n              ),\n              max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_jitter_ms_out\",\n                ssrc,\n              ),\n              volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_jitter_ms_out\",\n                ssrc,\n              ),\n              values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO, \"delta_jitter_ms_out\", ssrc),\n              _unit: {\n                avg: \"ms\",\n                min: \"ms\",\n                max: \"ms\",\n                volatility: \"percent\",\n              },\n            };\n            const bitrate = {\n              avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_kbs_out\",\n                false,\n                ssrc,\n              ),\n              min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_kbs_out\",\n                ssrc,\n              ),\n              max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_kbs_out\",\n                ssrc,\n              ),\n              volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_kbs_out\",\n                ssrc,\n              ),\n              values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO, \"delta_kbs_out\", ssrc),\n              _unit: {\n                avg: \"kbs\",\n                min: \"kbs\",\n                max: \"kbs\",\n                volatility: \"percent\",\n              },\n            };\n            const traffic = {\n              avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_KBytes_out\",\n                false,\n                ssrc,\n              ),\n              min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_KBytes_out\",\n                ssrc,\n              ),\n              max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_KBytes_out\",\n                ssrc,\n              ),\n              volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_KBytes_out\",\n                ssrc,\n              ),\n              values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO, \"delta_KBytes_out\", ssrc),\n              _unit: {\n                avg: \"KB\",\n                min: \"KB\",\n                max: \"KB\",\n                volatility: \"percent\",\n              },\n            };\n            const rtt = {\n              avg: averageRTT(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO, ssrc),\n              min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO, \"delta_rtt_ms_out\", ssrc),\n              max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO, \"delta_rtt_ms_out\", ssrc),\n              volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n                this._reports,\n                _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n                \"delta_rtt_ms_out\",\n                ssrc,\n              ),\n              values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO, \"delta_rtt_ms_out\", ssrc),\n              _unit: {\n                avg: \"ms\",\n                min: \"ms\",\n                max: \"ms\",\n                volatility: \"percent\",\n              },\n            };\n            const packetsLost = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n              \"total_packets_lost_out\",\n              ssrc,\n            );\n            const packetsReceived = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.lastOfReports)(\n              this._reports,\n              _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO,\n              \"total_packets_out\",\n              ssrc,\n            );\n            const loss = {\n              lost: packetsLost,\n              avg: Math.round(\n                ((packetsLost /\n                    (packetsLost + packetsReceived)) *\n                  100 || 0) * 100,\n              ) / 100,\n              values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO, \"delta_packets_lost_out\", ssrc),\n              _unit: {\n                avg: \"percent\",\n                lost: \"number\",\n              },\n            };\n\n            ssrcExporter[ssrc].jitter = jitter;\n            ssrcExporter[ssrc].rtt = rtt;\n            ssrcExporter[ssrc].traffic = traffic;\n            ssrcExporter[ssrc].bitrate = bitrate;\n            ssrcExporter[ssrc].loss = loss;\n            ssrcExporter[ssrc].limitations = limitationsPercent(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.VIDEO, ssrc);\n          }\n        });\n    }\n\n    return {\n      version: VERSION_EXPORTER,\n      configuration: {\n        frequency: this._cfg.refreshEvery,\n      },\n      started: this._start,\n      ended: this._end,\n      ua: {\n        agent: navigator.userAgent,\n        pname: this._cfg.pname,\n        user_id: this._cfg.uid,\n      },\n      call: {\n        call_id: this._cfg.cid,\n        events: this._events,\n      },\n      details: {\n        count: this._reports.length,\n        reports: this._cfg.record ? this._reports : [],\n        reference: this._referenceReport || null,\n      },\n      ssrc: ssrcExporter,\n      data: {\n        rtt: {\n          avg: averageRTTConnectivity(this._reports, \"data\"),\n          min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(\n            this._reports,\n            _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.DATA,\n            \"delta_rtt_connectivity_ms\",\n          ),\n          max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(\n            this._reports,\n            _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.DATA,\n            \"delta_rtt_connectivity_ms\",\n          ),\n          volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n            this._reports,\n            _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.DATA,\n            \"delta_rtt_connectivity_ms\",\n          ),\n          values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.DATA, \"delta_rtt_connectivity_ms\"),\n          _unit: {\n            avg: \"ms\",\n            min: \"ms\",\n            max: \"ms\",\n            volatility: \"percent\",\n          },\n        },\n        packetsLost: {\n          audio: {\n            in: {\n              avg:\n                Math.round(\n                  ((audioPacketsLost /\n                    (audioPacketsLost + audioPacketsReceived)) *\n                    100 || 0) * 100,\n                ) / 100,\n            },\n          },\n          video: {\n            in: {\n              avg:\n                Math.round(\n                  ((videoPacketsLost /\n                    (videoPacketsLost + videoPacketsReceived)) *\n                    100 || 0) * 100,\n                ) / 100,\n            },\n          },\n          unit: {\n            avg: \"percent\",\n          },\n        },\n        bitrate: {\n          in: {\n            avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(this._reports, \"data\", \"delta_kbs_in\"),\n            min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(this._reports, \"data\", \"delta_kbs_in\"),\n            max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(this._reports, \"data\", \"delta_kbs_in\"),\n            volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n              this._reports,\n              \"data\",\n              \"delta_kbs_in\",\n            ),\n            values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.DATA, \"delta_kbs_in\"),\n          },\n          out: {\n            avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(this._reports, \"data\", \"delta_kbs_out\"),\n            min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(this._reports, \"data\", \"delta_kbs_out\"),\n            max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(this._reports, \"data\", \"delta_kbs_out\"),\n            volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n              this._reports,\n              \"data\",\n              \"delta_kbs_out\",\n            ),\n            values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.DATA, \"delta_kbs_out\"),\n          },\n          unit: {\n            avg: \"kbs\",\n            min: \"kbs\",\n            max: \"kbs\",\n            volatility: \"percent\",\n          },\n        },\n        traffic: {\n          in: {\n            avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(this._reports, \"data\", \"delta_KBytes_in\"),\n            min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(this._reports, \"data\", \"delta_KBytes_in\"),\n            max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(this._reports, \"data\", \"delta_KBytes_in\"),\n            volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n              this._reports,\n              \"data\",\n              \"delta_KBytes_in\",\n            ),\n            values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.DATA, \"delta_KBytes_in\"),\n          },\n          out: {\n            avg: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.averageValuesOfReports)(\n              this._reports,\n              \"data\",\n              \"delta_KBytes_out\",\n            ),\n            min: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minValueOfReports)(this._reports, \"data\", \"delta_KBytes_out\"),\n            max: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.maxValueOfReports)(this._reports, \"data\", \"delta_KBytes_out\"),\n            volatility: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.volatilityValuesOfReports)(\n              this._reports,\n              \"data\",\n              \"delta_KBytes_out\",\n            ),\n            values: (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valuesOfReports)(this._reports, _utils_models__WEBPACK_IMPORTED_MODULE_2__.VALUE.DATA, \"delta_KBytes_out\"),\n          },\n          unit: {\n            avg: \"KBytes\",\n            min: \"KBytes\",\n            max: \"KBytes\",\n            volatility: \"percent\",\n          },\n        },\n        network: {\n          localConnection: getPath(this._reports),\n          remoteConnection: getRemotePath(this._reports),\n        },\n      },\n    };\n  }\n\n  updateConfig(config) {\n    this._cfg = config;\n  }\n\n  getLastReport() {\n    return this._reports.slice().pop() || null;\n  }\n\n  getBeforeLastReport() {\n    const duplicated = this._reports.slice();\n    duplicated.pop();\n    return duplicated.pop() || null;\n  }\n\n  getReportsNumber() {\n    return this._reports.length;\n  }\n}\n\n\n//# sourceURL=webpack://WebRTCMetrics/./src/exporter.js?");

/***/ }),

/***/ "./src/extractor.js":
/*!**************************!*\
  !*** ./src/extractor.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"extract\": () => (/* binding */ extract),\n/* harmony export */   \"extractPassthroughFields\": () => (/* binding */ extractPassthroughFields)\n/* harmony export */ });\n/* harmony import */ var _utils_models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/models */ \"./src/utils/models.js\");\n/* harmony import */ var _utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/helper */ \"./src/utils/helper.js\");\n/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/log */ \"./src/utils/log.js\");\n\n\n\n\n\n\nconst moduleName = \"extractor   \";\n\nconst extractPlayoutInformation = (report, previousReport) => {\n  const previousSynthetized = previousReport ? (previousReport[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.SYNTHETIZED_SAMPLES_DURATION] * 1000) || 0 : 0;\n  const currentSynthetized = report ? (report[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.SYNTHETIZED_SAMPLES_DURATION] * 1000) || 0 : 0;\n  const totalSamplesDuration = report ? (report[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_SAMPLES_DURATION] * 1000) || 0 : 0;\n  const previousTotalSamplesDuration = previousReport ? (previousReport[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_SAMPLES_DURATION] * 1000) || 0 : 0;\n  const delta = currentSynthetized - previousSynthetized;\n  const deltaDuration = totalSamplesDuration - previousTotalSamplesDuration;\n  const totalDelay = report ? report[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_PLAYOUT_DELAY] || 0 : 0;\n  const totalSamplesCount = report ? report[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_SAMPLES_COUNT] || 0 : 0;\n\n  const deltaDelay = totalSamplesCount ? totalDelay / totalSamplesCount : 0;\n  const deltaPercentSynthetized = deltaDuration ? (delta / deltaDuration) * 100 : 0;\n  const totalPercentSynthetized = totalSamplesDuration ? (currentSynthetized / totalSamplesDuration) * 100 : 0;\n\n  return {\n    total_synthetized_ms_in: currentSynthetized,\n    delta_synthetized_ms_in: delta,\n    percent_synthetized_in: deltaPercentSynthetized,\n    total_percent_synthetized_in: totalPercentSynthetized,\n    total_playout_ms_in: totalDelay,\n    delta_playout_delay_ms_in: deltaDelay,\n  };\n};\n\nconst extractRTTBasedOnRTCP = (bunch, kind, referenceReport, previousBunch) => {\n  let supportOfMeasure = false;\n  const previousRTT = previousBunch[kind].total_rtt_ms_out;\n  const previousNbMeasure = previousBunch[kind].total_rtt_measure_out;\n  const referenceRTT = referenceReport\n    ? referenceReport[kind].total_rtt_ms_out\n    : 0;\n  const referenceNbMeasure = referenceReport\n    ? referenceReport[kind].total_rtt_measure_out\n    : 0;\n\n  const returnedValuesByDefault = {\n    rtt: null,\n    totalRTT: previousRTT,\n    totalRTTMeasurements: previousNbMeasure,\n  };\n\n  if (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TIMESTAMP] === previousBunch[kind].timestamp_out) {\n    return returnedValuesByDefault;\n  }\n\n  // If RTT is not part of the stat - return\n  if (!Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.ROUND_TRIP_TIME)) {\n    return returnedValuesByDefault;\n  }\n\n  // If no measure yet or no new measure - return\n  if (\n    Object.prototype.hasOwnProperty.call(\n      bunch,\n      _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_ROUND_TRIP_TIME_MEASUREMENTS,\n    )\n  ) {\n    supportOfMeasure = true;\n    if (\n      Number(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_ROUND_TRIP_TIME_MEASUREMENTS]) === 0 ||\n      Number(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_ROUND_TRIP_TIME_MEASUREMENTS]) -\n        referenceNbMeasure ===\n        previousNbMeasure\n    ) {\n      return returnedValuesByDefault;\n    }\n  }\n\n  const currentRTT = Number(1000) * Number(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.ROUND_TRIP_TIME]);\n  let currentTotalRTT = previousRTT + currentRTT;\n  let currentTotalMeasurements = previousNbMeasure + 1;\n\n  // If support of totalRoundTripTime\n  if (supportOfMeasure) {\n    currentTotalRTT =\n      Number(1000) * Number(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_ROUND_TRIP_TIME]) -\n      referenceRTT;\n    currentTotalMeasurements =\n      Number(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_ROUND_TRIP_TIME_MEASUREMENTS]) -\n      referenceNbMeasure;\n  }\n\n  return {\n    rtt: currentRTT,\n    totalRTT: currentTotalRTT,\n    totalRTTMeasurements: currentTotalMeasurements,\n  };\n};\n\nconst extractRTTBasedOnSTUNConnectivityCheck = (\n  bunch,\n  kind,\n  referenceReport,\n  previousBunch,\n) => {\n  // If RTT is not part of the stat - return null value\n  if (\n    !Object.prototype.hasOwnProperty.call(\n      bunch,\n      _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.CURRENT_ROUND_TRIP_TIME,\n    )\n  ) {\n    return {\n      rtt: null,\n      totalRTT: previousBunch[kind].total_rtt_connectivity_ms,\n      totalRTTMeasurements:\n        previousBunch[kind].total_rtt_connectivity_measure,\n    };\n  }\n\n  const currentRTT =\n    Number(1000) * Number(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.CURRENT_ROUND_TRIP_TIME]);\n  let currentTotalRTT =\n    previousBunch[kind].total_rtt_connectivity_ms + currentRTT;\n  let currentTotalMeasurements =\n    previousBunch[kind].total_rtt_connectivity_measure + 1;\n\n  // If support of totalRoundTripTime\n  if (\n    Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_ROUND_TRIP_TIME)\n  ) {\n    currentTotalRTT =\n      Number(1000) * Number(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_ROUND_TRIP_TIME]) -\n      (referenceReport\n        ? referenceReport[kind].total_rtt_connectivity_ms\n        : 0);\n  }\n  // If support of responsesReceived\n  if (\n    Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.RESPONSES_RECEIVED)\n  ) {\n    currentTotalMeasurements =\n      Number(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.RESPONSES_RECEIVED]) -\n      (referenceReport\n        ? referenceReport[kind].total_rtt_connectivity_measure\n        : 0);\n  }\n\n  return {\n    rtt: currentRTT,\n    totalRTT: currentTotalRTT,\n    totalRTTMeasurements: currentTotalMeasurements,\n  };\n};\n\nconst extractLastJitter = (bunch, kind, previousBunch) => {\n  if (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TIMESTAMP] === previousBunch[kind].timestamp_out) {\n    return null;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.JITTER)) {\n    return null;\n  }\n\n  return Number(1000) * (Number(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.JITTER]) || 0);\n};\n\nconst extractJitterBufferInfo = (bunch, kind, previousBunch) => {\n  const jitterBufferDelay = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.JITTER_BUFFER_DELAY] * 1000 || 0;\n  const jitterBufferEmittedCount = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.JITTER_BUFFER_EMITTED_COUNT] || 0;\n\n  const deltaJitterBufferDelay = jitterBufferDelay - previousBunch[kind].total_time_jitter_buffer_delay_in;\n  const deltaJitterBufferEmittedCount = jitterBufferEmittedCount - previousBunch[kind].total_jitter_emitted_in;\n\n  return {\n    delta_ms_jitter_buffer_delay: deltaJitterBufferEmittedCount ? deltaJitterBufferDelay / deltaJitterBufferEmittedCount : 0,\n    total_time_jitter_buffer_delay: jitterBufferDelay,\n    total_time_jitter_emitted: jitterBufferEmittedCount,\n  };\n};\n\nconst extractDecodeTime = (bunch, previousBunch) => {\n  if (\n    !Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.FRAMES_DECODED) ||\n    !Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_DECODE_TIME)\n  ) {\n    return {\n      delta_ms_decode_frame:\n        previousBunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].delta_decode_frame_ms_in,\n      frames_decoded: previousBunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_frames_decoded_in,\n      total_decode_time: previousBunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_time_decoded_in,\n    };\n  }\n\n  const decodedFrames = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.FRAMES_DECODED];\n  const totalDecodeTime = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_DECODE_TIME] * 1000; // in ms\n  const totalProcessingDelay = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_PROCESSING_DELAY] * 1000 || 0; // in ms\n  const totalAssemblyTime = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_ASSEMBLY_TIME] * 1000 || 0; // in ms\n\n  const totalProcessingDelayDelta = totalProcessingDelay - previousBunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_time_processing_delay_in;\n  const decodeTimeDelta = totalDecodeTime - previousBunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_time_decoded_in;\n  const frameDelta = decodedFrames - previousBunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_frames_decoded_in;\n  const totalAssemblyTimeDelta = totalAssemblyTime - previousBunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_time_assembly_delay_in;\n\n  return {\n    frames_decoded: decodedFrames,\n    delta_ms_decode_frame: frameDelta > 0 ? decodeTimeDelta / frameDelta : 0,\n    delta_ms_processing_delay: frameDelta > 0 ? totalProcessingDelayDelta / frameDelta : 0,\n    delta_ms_assembly_delay: frameDelta > 0 ? totalAssemblyTimeDelta / frameDelta : 0,\n    total_time_processing_delay: totalProcessingDelay,\n    total_decode_time: totalDecodeTime,\n    total_assembly_time: totalAssemblyTime,\n  };\n};\n\nconst extractEncodeTime = (bunch, previousBunch) => {\n  if (\n    !Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.FRAMES_ENCODED) ||\n    !Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_ENCODE_TIME)\n  ) {\n    return {\n      delta_ms_encode_frame: previousBunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].delta_encode_frame_ms_out,\n      frames_encoded: previousBunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_frames_encoded_out,\n      total_encode_time: previousBunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_time_encoded_out,\n    };\n  }\n\n  const encodedFrames = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.FRAMES_ENCODED];\n  const totalEncodeTime = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_ENCODE_TIME];\n\n  const encodeTimeDelta =\n    totalEncodeTime - previousBunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_time_encoded_out;\n  const frameDelta =\n    encodedFrames - previousBunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_frames_encoded_out;\n  const framesEncodedDelta =\n    frameDelta > 0 && encodeTimeDelta\n      ? (encodeTimeDelta * 1000) / frameDelta\n      : 0;\n\n  return {\n    delta_ms_encode_frame: framesEncodedDelta,\n    frames_encoded: encodedFrames,\n    total_encode_time: totalEncodeTime,\n  };\n};\n\nconst extractAudioVideoPacketSent = (\n  bunch,\n  kind,\n  previousBunch,\n  referenceReport,\n) => {\n  const packetsSent =\n    Number(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PACKETS_SENT]) ||\n    0 - (referenceReport ? referenceReport[kind].total_packets_out : 0);\n  const deltaPacketsSent = packetsSent - previousBunch[kind].total_packets_out;\n  const totalPacketSendDelay = Number(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TOTAL_PACKETS_SEND_DELAY]) * 1000 ||\n    0 - (referenceReport ? referenceReport[kind].total_time_packets_delay_out : 0);\n  const deltaPacketsDelay = totalPacketSendDelay - previousBunch[kind].total_time_packets_delay_out;\n  const deltaAvgPacketSendDelay = deltaPacketsSent ? deltaPacketsDelay / deltaPacketsSent : 0;\n  const KBytesSent = (Number(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.BYTES_SENT]) / 1024) - (referenceReport ? referenceReport[kind].total_KBytes_out : 0);\n  const deltaKBytesSent = KBytesSent - previousBunch[kind].total_KBytes_out;\n  const timestamp = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TIMESTAMP] || Date.now();\n  const referenceTimestamp = referenceReport ? referenceReport.timestamp : null;\n  let previousTimestamp = previousBunch.timestamp;\n  if (!previousTimestamp && referenceTimestamp) {\n    previousTimestamp = referenceTimestamp;\n  }\n  const deltaMs = previousTimestamp ? timestamp - previousTimestamp : 0;\n  const kbsSent = deltaMs > 0 ? ((deltaKBytesSent * 0.008 * 1024) / deltaMs) * 1000 : 0; // kbs = kilo bits per second\n\n  return {\n    packetsSent,\n    deltaPacketsSent,\n    KBytesSent,\n    deltaKBytesSent,\n    kbsSent,\n    deltaAvgPacketSendDelay,\n    totalPacketSendDelay,\n  };\n};\n\nconst extractAudioVideoPacketLost = (\n    bunch,\n    kind,\n    previousBunch,\n    referenceReport,\n) => {\n  let packetsLost = previousBunch[kind].total_packets_lost_out;\n  let deltaPacketsLost = 0;\n  let fractionLost = 0;\n  if (Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PACKETS_LOST)) {\n    packetsLost = Number(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PACKETS_LOST]) || 0 - (referenceReport ? referenceReport[kind].total_packets_lost_out : 0);\n    deltaPacketsLost = packetsLost - previousBunch[kind].total_packets_lost_out;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.FRACTION_LOST)) {\n    fractionLost = Number(100 * bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.FRACTION_LOST]);\n  }\n  return {\n    packetsLost,\n    deltaPacketsLost,\n    fractionLost,\n  };\n};\n\nconst extractAudioVideoPacketReceived = (\n  bunch,\n  kind,\n  previousBunch,\n  referenceReport,\n) => {\n  if (\n    !Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PACKETS_RECEIVED) ||\n    !Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PACKETS_LOST) ||\n    !Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.BYTES_RECEIVED)\n  ) {\n    return {\n      percent_packets_lost: previousBunch[kind].percent_packets_lost_in,\n      packetsReceived: previousBunch[kind].total_packets_in,\n      packetsLost: previousBunch[kind].total_packets_lost_in,\n      bytesReceived: previousBunch[kind].total_KBytes_in,\n    };\n  }\n\n  const packetsReceived =\n    Number(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PACKETS_RECEIVED]) ||\n    0 - (referenceReport ? referenceReport[kind].total_packets_in : 0);\n  const packetsLost =\n    Number(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PACKETS_LOST]) ||\n    0 - (referenceReport ? referenceReport[kind].total_packets_lost_in : 0);\n  const deltaPacketsLost =\n    packetsLost - previousBunch[kind].total_packets_lost_in;\n  const deltaPacketsReceived =\n    packetsReceived - previousBunch[kind].total_packets_in;\n  const percentPacketsLost =\n    packetsReceived !== previousBunch[kind].total_packets_in\n      ? (deltaPacketsLost * 100) / (deltaPacketsLost + deltaPacketsReceived)\n      : 0.0;\n  const KBytesReceived = (Number(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.BYTES_RECEIVED]) / 1024) - (referenceReport ? referenceReport[kind].total_KBytes_in : 0);\n  const deltaKBytesReceived = KBytesReceived - previousBunch[kind].total_KBytes_in;\n  const timestamp = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TIMESTAMP] || Date.now();\n  const referenceTimestamp = referenceReport ? referenceReport.timestamp : null;\n  let previousTimestamp = previousBunch.timestamp;\n  if (!previousTimestamp && referenceTimestamp) {\n    previousTimestamp = referenceTimestamp;\n  }\n  const deltaMs = previousTimestamp ? timestamp - previousTimestamp : 0;\n  const kbsReceived = deltaMs > 0 ? ((deltaKBytesReceived * 0.008 * 1024) / deltaMs) * 1000 : 0; // kbs = kilo bits per second\n\n  return {\n    percentPacketsLost,\n    packetsReceived,\n    deltaPacketsReceived,\n    packetsLost,\n    deltaPacketsLost,\n    KBytesReceived,\n    deltaKBytesReceived,\n    kbsReceived,\n  };\n};\n\nconst extractRelayProtocolUsed = (bunch) => {\n  const candidateType = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.CANDIDATE_TYPE];\n  if (candidateType !== \"relay\") {\n    return \"\";\n  }\n  return bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.RELAY_PROTOCOL] || \"\";\n};\n\nconst extractInfrastructureValue = (bunch) => {\n  if (!Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.NETWORK_TYPE)) {\n    // Assuming Wifi when not provided (firefox/Safari at this time)\n    return _utils_models__WEBPACK_IMPORTED_MODULE_0__.INFRASTRUCTURE_VALUE.WIFI;\n  }\n\n  switch (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.NETWORK_TYPE]) {\n    case _utils_models__WEBPACK_IMPORTED_MODULE_0__.INFRASTRUCTURE_LABEL.ETHERNET:\n      return _utils_models__WEBPACK_IMPORTED_MODULE_0__.INFRASTRUCTURE_VALUE.ETHERNET;\n    case _utils_models__WEBPACK_IMPORTED_MODULE_0__.INFRASTRUCTURE_LABEL.CELLULAR_4G:\n      return _utils_models__WEBPACK_IMPORTED_MODULE_0__.INFRASTRUCTURE_VALUE.CELLULAR_4G;\n    case _utils_models__WEBPACK_IMPORTED_MODULE_0__.INFRASTRUCTURE_LABEL.WIFI:\n      return _utils_models__WEBPACK_IMPORTED_MODULE_0__.INFRASTRUCTURE_VALUE.WIFI;\n    default:\n      return _utils_models__WEBPACK_IMPORTED_MODULE_0__.INFRASTRUCTURE_VALUE.CELLULAR;\n  }\n};\n\nconst extractVideoSize = (bunch) => {\n  if (\n    !Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.FRAME_HEIGHT) ||\n    !Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.FRAME_WIDTH)\n  ) {\n    return { width: 0, height: 0, framerate: 0 };\n  }\n\n  return {\n    width: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.FRAME_WIDTH] || 0,\n    height: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.FRAME_HEIGHT] || 0,\n    framerate: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.FRAMES_PER_SECOND || 0],\n  };\n};\n\nconst extractQualityLimitation = (bunch) => {\n  const reason = Object.prototype.hasOwnProperty.call(\n    bunch,\n    _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.QUALITY_LIMITATION_REASON,\n  )\n    ? bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.QUALITY_LIMITATION_REASON]\n    : null;\n  const resolutionChanges = Object.prototype.hasOwnProperty.call(\n    bunch,\n    _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.QUALITY_LIMITATION_RESOLUTION_CHANGES,\n  )\n    ? bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.QUALITY_LIMITATION_RESOLUTION_CHANGES]\n    : null;\n  const durations = Object.prototype.hasOwnProperty.call(\n    bunch,\n    _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.QUALITY_LIMITATION_DURATIONS,\n  )\n    ? bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.QUALITY_LIMITATION_DURATIONS]\n    : null;\n\n  if (durations) {\n    Object.keys(durations).forEach((key) => {\n      if (durations[key] > 1000) {\n        durations[key] = Number(durations[key] / 1000);\n      }\n    });\n  }\n  return { reason, durations, resolutionChanges };\n};\n\nconst extractVideoGlitch = (bunch, kind, previousReport, referenceReport) => {\n  if (\n    !Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.FREEZE_COUNT) ||\n    !Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PAUSE_COUNT)\n  ) {\n    return {\n      freezeCount: previousReport[kind].total_glitch_in.freeze,\n      pauseCount: previousReport[kind].total_glitch_in.pause,\n      deltaFreezeCount: 0,\n      deltaPauseCount: 0,\n    };\n  }\n\n  const freezeCount = (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.FREEZE_COUNT] || 0) - (referenceReport ? referenceReport[kind].total_glitch_in.freeze : 0);\n  const pauseCount = (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PAUSE_COUNT] || 0) - (referenceReport ? referenceReport[kind].total_glitch_in.pause : 0);\n\n  return {\n    freezeCount,\n    pauseCount,\n    deltaFreezeCount: freezeCount - previousReport[kind].total_glitch_in.freeze,\n    deltaPauseCount: pauseCount - previousReport[kind].total_glitch_in.pause,\n  };\n};\n\nconst extractNackAndPliCountSentWhenReceiving = (bunch, previousReport, referenceReport) => {\n  if (\n    !Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PLI) ||\n    !Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.NACK)\n  ) {\n    return {\n      pliCount: previousReport.total_pli_sent_in,\n      nackCount: previousReport.total_nack_sent_in,\n      deltaPliCount: 0,\n      deltaNackCount: 0,\n    };\n  }\n\n  const pliCount = (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PLI] || 0) - (referenceReport ? referenceReport[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_pli_sent_in : 0);\n  const nackCount = (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.NACK] || 0) - (referenceReport ? referenceReport[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_nack_sent_in : 0);\n\n  return {\n    pliCount,\n    nackCount,\n    deltaPliCount: pliCount - previousReport[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_pli_sent_in,\n    deltaNackCount: nackCount - previousReport[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_nack_sent_in,\n  };\n};\n\nconst extractNackAndPliCountReceivedWhenSending = (bunch, previousReport, referenceReport) => {\n  if (\n    !Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PLI) ||\n    !Object.prototype.hasOwnProperty.call(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.NACK)\n  ) {\n    return {\n      pliCount: previousReport.total_pli_received_out,\n      nackCount: previousReport.total_nack_received_out,\n      deltaPliCount: 0,\n      deltaNackCount: 0,\n    };\n  }\n\n  const pliCount = (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PLI] || 0) - (referenceReport ? referenceReport[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_pli_received_out : 0);\n  const nackCount = (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.NACK] || 0) - (referenceReport ? referenceReport[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_nack_received_out : 0);\n\n  return {\n    pliCount,\n    nackCount,\n    deltaPliCount: pliCount - previousReport[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_pli_received_out,\n    deltaNackCount: nackCount - previousReport[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO].total_nack_received_out,\n  };\n};\n\nconst extractAudioCodec = (bunch) => ({\n  channels: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.CHANNELS] || null,\n  clock_rate: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.CLOCK_RATE] || null,\n  mime_type: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.MIME_TYPE] || null,\n  sdp_fmtp_line: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.SDP_FMTP_LINE] || null,\n});\n\nconst extractVideoCodec = (bunch) => ({\n  clock_rate: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.CLOCK_RATE] || null,\n  mime_type: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.MIME_TYPE] || null,\n});\n\nconst extractBytesSentReceived = (bunch, previousBunch, referenceReport) => {\n  const totalKBytesReceived =\n    (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.BYTES_RECEIVED] || 0) / 1024 -\n    (referenceReport ? referenceReport.data.total_KBytes_in : 0);\n  const totalKBytesSent =\n    (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.BYTES_SENT] || 0) / 1024 -\n    (referenceReport ? referenceReport.data.total_KBytes_out : 0);\n\n  const timestamp = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TIMESTAMP] || Date.now();\n  const KBytesReceived =\n    totalKBytesReceived - previousBunch.data.total_KBytes_in;\n  const KBytesSent = totalKBytesSent - previousBunch.data.total_KBytes_out;\n\n  const referenceTimestamp = referenceReport ? referenceReport.timestamp : null;\n  let previousTimestamp = previousBunch.timestamp;\n  if (!previousTimestamp && referenceTimestamp) {\n    previousTimestamp = referenceTimestamp;\n  }\n  const deltaMs = previousTimestamp ? timestamp - previousTimestamp : 0;\n  const kbsSpeedReceived =\n    deltaMs > 0 ? ((KBytesReceived * 0.008 * 1024) / deltaMs) * 1000 : 0; // kbs = kilo bits per second\n  const kbsSpeedSent =\n    deltaMs > 0 ? ((KBytesSent * 0.008 * 1024) / deltaMs) * 1000 : 0;\n\n  return {\n    total_KBytes_received: totalKBytesReceived,\n    total_KBytes_sent: totalKBytesSent,\n    delta_KBytes_received: KBytesReceived,\n    delta_KBytes_sent: KBytesSent,\n    kbs_speed_received: kbsSpeedReceived,\n    kbs_speed_sent: kbsSpeedSent,\n  };\n};\n\nconst extractAvailableBandwidth = (bunch) => {\n  const kbsIncomingBandwidth =\n    bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.AVAILABLE_INCOMING_BITRATE] / 1024 || 0;\n  const kbsOutgoingBandwidth =\n    bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.AVAILABLE_OUTGOING_BITRATE] / 1024 || 0;\n\n  return {\n    kbs_incoming_bandwidth: kbsIncomingBandwidth,\n    kbs_outgoing_bandwidth: kbsOutgoingBandwidth,\n  };\n};\n\nconst extract = (bunch, previousBunch, pname, referenceReport, raw, oldRaw, _refPC) => {\n  if (!bunch) {\n    return [];\n  }\n\n  (0,_utils_log__WEBPACK_IMPORTED_MODULE_2__.debug)(\n    moduleName,\n    `analyze() - got stats ${bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TYPE]} for ${pname}`,\n    bunch,\n  );\n\n  switch (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TYPE]) {\n    case _utils_models__WEBPACK_IMPORTED_MODULE_0__.TYPE.CANDIDATE_PAIR:\n      let selectedPairForFirefox = false;\n      let selectedPair = false;\n      // get Transport report\n      if (raw.has(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TRANSPORT_ID])) {\n        const transportReport = raw.get(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TRANSPORT_ID]);\n        if (transportReport[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.SELECTED_CANDIDATEPAIR_ID] === bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.ID]) {\n          selectedPair = true;\n        }\n      }\n\n      // FF: NO RTCTransportStats report - Use candidate-pair with selected=true\n      if (_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.SELECTED in bunch && bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.SELECTED]) {\n        selectedPairForFirefox = true;\n      }\n\n      if (selectedPair || selectedPairForFirefox) {\n        const localCandidateId = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.LOCAL_CANDIDATE_ID];\n        const remoteCandidateId = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.REMOTE_CANDIDATE_ID];\n        const selectedCandidatePairId = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.ID];\n\n        const valueSentReceived = extractBytesSentReceived(\n          bunch,\n          previousBunch,\n          referenceReport,\n        );\n        const bandwidth = extractAvailableBandwidth(bunch);\n        const rttConnectivity = extractRTTBasedOnSTUNConnectivityCheck(\n          bunch,\n          \"data\",\n          referenceReport,\n          previousBunch,\n        );\n\n        const result = [\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.NETWORK,\n            value: { local_candidate_id: localCandidateId },\n          },\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.NETWORK,\n            value: { remote_candidate_id: remoteCandidateId },\n          },\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.DATA,\n            value: { total_KBytes_in: valueSentReceived.total_KBytes_received },\n          },\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.DATA,\n            value: { total_KBytes_out: valueSentReceived.total_KBytes_sent },\n          },\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.DATA,\n            value: { delta_KBytes_in: valueSentReceived.delta_KBytes_received },\n          },\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.DATA,\n            value: { delta_KBytes_out: valueSentReceived.delta_KBytes_sent },\n          },\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.DATA,\n            value: { delta_kbs_in: valueSentReceived.kbs_speed_received },\n          },\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.DATA,\n            value: { delta_kbs_out: valueSentReceived.kbs_speed_sent },\n          },\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.DATA,\n            value: { delta_kbs_bandwidth_in: bandwidth.kbs_incoming_bandwidth },\n          },\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.DATA,\n            value: {\n              delta_kbs_bandwidth_out: bandwidth.kbs_outgoing_bandwidth,\n            },\n          },\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.DATA,\n            value: { delta_rtt_connectivity_ms: rttConnectivity.rtt },\n          },\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.DATA,\n            value: { total_rtt_connectivity_ms: rttConnectivity.totalRTT },\n          },\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.DATA,\n            value: {\n              total_rtt_connectivity_measure:\n                rttConnectivity.totalRTTMeasurements,\n            },\n          },\n        ];\n\n        if (selectedPairForFirefox) {\n          result.push(\n            {\n              type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.NETWORK,\n              internal: \"selectedPairChanged\",\n              value: { selected_candidate_pair_id: selectedCandidatePairId },\n            },\n          );\n        }\n        return result;\n      }\n      break;\n    case _utils_models__WEBPACK_IMPORTED_MODULE_0__.TYPE.LOCAL_CANDIDATE:\n      if (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.ID] === previousBunch.network.local_candidate_id) {\n        return [\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.NETWORK,\n            value: { infrastructure: extractInfrastructureValue(bunch) },\n          },\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.NETWORK,\n            value: {\n              local_candidate_type: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.CANDIDATE_TYPE] || \"\",\n            },\n          },\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.NETWORK,\n            value: { local_candidate_protocol: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PROTOCOL] || \"\" },\n          },\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.NETWORK,\n            value: {\n              local_candidate_relay_protocol: extractRelayProtocolUsed(bunch),\n            },\n          },\n        ];\n      }\n      break;\n    case _utils_models__WEBPACK_IMPORTED_MODULE_0__.TYPE.REMOTE_CANDIDATE:\n      if (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.ID] === previousBunch.network.remote_candidate_id) {\n        return [\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.NETWORK,\n            value: {\n              remote_candidate_type: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.CANDIDATE_TYPE] || \"\",\n            },\n          },\n          {\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.NETWORK,\n            value: {\n              remote_candidate_protocol: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PROTOCOL] || \"\",\n            },\n          },\n        ];\n      }\n      break;\n    case _utils_models__WEBPACK_IMPORTED_MODULE_0__.TYPE.INBOUND_RTP: {\n      // get SSRC and associated data\n      const ssrc = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.SSRC];\n      const previousSSRCBunch = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getSSRCDataFromBunch)(ssrc, previousBunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.INBOUND);\n      if (previousSSRCBunch) {\n        previousSSRCBunch.timestamp = previousBunch.timestamp;\n      }\n      const referenceSSRCBunch = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getSSRCDataFromBunch)(ssrc, referenceReport, _utils_models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.INBOUND);\n      if (referenceSSRCBunch) {\n        referenceSSRCBunch.timestamp = referenceReport.timestamp;\n      }\n\n      if (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.MEDIA_TYPE] === _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO) {\n        // Packets stats and Bytes\n        const data = extractAudioVideoPacketReceived(\n            bunch,\n            _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO,\n            previousSSRCBunch,\n            referenceSSRCBunch,\n        );\n\n        // Jitter stats\n        const jitter = extractLastJitter(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO, previousSSRCBunch);\n\n        // Codec stats\n        const audioInputCodecId = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.CODEC_ID] || \"\";\n\n        // Audio level in\n        const audioLevel = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.AUDIO_LEVEL] || 0;\n\n        // average playout delay\n        let playout = null;\n        if (raw.has(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PLAYOUT_ID])) {\n          const playoutReport = raw.get(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PLAYOUT_ID]);\n          const previousPlayoutReport = oldRaw ? oldRaw.get(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.PLAYOUT_ID]) : null;\n          playout = extractPlayoutInformation(playoutReport, previousPlayoutReport);\n        }\n\n        const jitterBuffer = extractJitterBufferInfo(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO, previousSSRCBunch);\n\n        return [\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { codec_id_in: audioInputCodecId },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { total_packets_in: data.packetsReceived },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { delta_packets_in: data.deltaPacketsReceived },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { total_packets_lost_in: data.packetsLost },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { delta_packets_lost_in: data.deltaPacketsLost },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { percent_packets_lost_in: data.percentPacketsLost },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { total_KBytes_in: data.KBytesReceived },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            internal: \"bytesReceivedChanged\",\n            value: { delta_KBytes_in: data.deltaKBytesReceived },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { delta_kbs_in: data.kbsReceived },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { delta_jitter_ms_in: jitter },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { delta_jitter_buffer_delay_ms_in: jitterBuffer.delta_ms_jitter_buffer_delay },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { total_time_jitter_buffer_delay_in: jitterBuffer.total_time_jitter_buffer_delay },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { total_jitter_emitted_in: jitterBuffer.total_time_jitter_emitted },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { track_in: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TRACK_IDENTIFIER] },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            internal: \"ssrcIdentifierIn\",\n            value: { ssrc_in: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.SSRC] },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { level_in: audioLevel },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { delta_synthetized_ms_in: playout ? playout.delta_synthetized_ms_in : 0 },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { total_synthetized_ms_in: playout ? playout.total_synthetized_ms_in : 0 },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { delta_playout_delay_ms_in: playout ? playout.delta_playout_delay_ms_in : 0 },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { total_playout_ms_in: playout ? playout.total_playout_ms_in : 0 },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { percent_synthetized_in: playout ? playout.percent_synthetized_in : 0 },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { total_percent_synthetized_in: playout ? playout.total_percent_synthetized_in : 0 },\n          },\n        ];\n      }\n\n      if (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.MEDIA_TYPE] === _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO) {\n        // Decode time stats\n        const data = extractDecodeTime(bunch, previousSSRCBunch);\n\n        // Packets stats and Bytes\n        const packetsData = extractAudioVideoPacketReceived(\n            bunch,\n            _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO,\n            previousSSRCBunch,\n            referenceSSRCBunch,\n        );\n\n        // Jitter stats\n        const jitter = extractLastJitter(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO, previousSSRCBunch);\n\n        // Codec stats\n        const decoderImplementation =\n            bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.DECODER_IMPLEMENTATION] || null;\n        const videoInputCodecId = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.CODEC_ID] || null;\n\n        // Video size\n        const inputVideo = extractVideoSize(bunch);\n\n        // Nack & Pli stats\n        const nackPliData = extractNackAndPliCountSentWhenReceiving(\n          bunch,\n          previousSSRCBunch,\n          referenceSSRCBunch,\n        );\n\n        // Glitch\n        const freezePauseData = extractVideoGlitch(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO, previousSSRCBunch, referenceSSRCBunch);\n\n        // Jitter buffer\n        const jitterBuffer = extractJitterBufferInfo(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO, previousSSRCBunch);\n\n        return [\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { codec_id_in: videoInputCodecId },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_packets_in: packetsData.packetsReceived },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_packets_in: packetsData.deltaPacketsReceived },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_packets_lost_in: packetsData.packetsLost },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_packets_lost_in: packetsData.deltaPacketsLost },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { percent_packets_lost_in: packetsData.percentPacketsLost },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_KBytes_in: packetsData.KBytesReceived },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            internal: \"bytesReceivedChanged\",\n            value: { delta_KBytes_in: packetsData.deltaKBytesReceived },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_kbs_in: packetsData.kbsReceived },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_jitter_ms_in: jitter },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_jitter_buffer_delay_ms_in: jitterBuffer.delta_ms_jitter_buffer_delay },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_time_jitter_buffer_delay_in: jitterBuffer.total_time_jitter_buffer_delay },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_jitter_emitted_in: jitterBuffer.total_time_jitter_emitted },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { decoder_in: decoderImplementation },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_decode_frame_ms_in: data.delta_ms_decode_frame },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_frames_decoded_in: data.frames_decoded },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_processing_delay_ms_in: data.delta_ms_processing_delay },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_time_processing_delay_in: data.total_time_processing_delay },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_assembly_delay_ms_in: data.delta_ms_assembly_delay },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_time_assembly_delay_in: data.total_assembly_time },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_time_decoded_in: data.total_decode_time },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_nack_sent_in: nackPliData.nackCount },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_nack_sent_in: nackPliData.deltaNackCount },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_pli_sent_in: nackPliData.pliCount },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_pli_sent_in: nackPliData.deltaPliCount },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { size_in: inputVideo },\n            internal: \"inputSizeChanged\",\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { track_in: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TRACK_IDENTIFIER] },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            internal: \"ssrcIdentifierIn\",\n            value: { ssrc_in: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.SSRC] },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: {\n              total_glitch_in: { freeze: freezePauseData.freezeCount, pause: freezePauseData.pauseCount },\n              delta_glitch_in: { freeze: freezePauseData.deltaFreezeCount, pause: freezePauseData.deltaPauseCount },\n            },\n            internal: \"glitchChanged\",\n          },\n        ];\n      }\n      break;\n    }\n    case _utils_models__WEBPACK_IMPORTED_MODULE_0__.TYPE.OUTBOUND_RTP: {\n      const active = !!bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.MEDIA_SOURCE_ID];\n\n      // get SSRC and associated data\n      const ssrc = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.SSRC];\n      const previousSSRCBunch = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getSSRCDataFromBunch)(ssrc, previousBunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.OUTBOUND);\n      if (previousSSRCBunch) {\n        previousSSRCBunch.timestamp = previousBunch.timestamp;\n      }\n      const referenceSSRCBunch = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getSSRCDataFromBunch)(ssrc, referenceReport, _utils_models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.OUTBOUND);\n      if (referenceSSRCBunch) {\n        referenceSSRCBunch.timestamp = referenceReport.timestamp;\n      }\n\n      let trackOut = \"\";\n      let audioLevel = 0;\n      let size = { width: 0, height: 0, framerate: 0 };\n      if (active && raw.has(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.MEDIA_SOURCE_ID])) {\n        const mediaSourceReport = raw.get(bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.MEDIA_SOURCE_ID]);\n        trackOut = mediaSourceReport[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TRACK_IDENTIFIER];\n        if (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.KIND] === _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO) {\n          audioLevel = mediaSourceReport[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.AUDIO_LEVEL];\n        } else {\n          size = { width: mediaSourceReport[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.WIDTH] || null, height: mediaSourceReport[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.HEIGHT] || null, framerate: mediaSourceReport[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.FRAMES_PER_SECOND] || null };\n        }\n      }\n\n      let deviceLabel = \"\";\n      if (trackOut) {\n        const track = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.findTrackInPeerConnectionById)(trackOut, _refPC);\n        if (track) {\n          deviceLabel = track.label;\n        }\n      }\n\n      if (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.MEDIA_TYPE] === _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO) {\n        const audioOutputCodecId = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.CODEC_ID] || null;\n\n        // FF: no media-source, try to find the track from the sender (first track of kind found)\n        if (!trackOut) {\n          const track = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.findOutgoingTrackFromPeerConnectionByKind)(\"audio\", _refPC);\n          if (track) {\n            trackOut = track.id;\n            deviceLabel = track.label;\n          }\n        }\n\n        // packets and bytes\n        const data = extractAudioVideoPacketSent(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO, previousSSRCBunch, referenceSSRCBunch);\n\n        return [\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            internal: \"mediaSourceUpdated\",\n            value: { active_out: active },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { device_out: deviceLabel },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { codec_id_out: audioOutputCodecId },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { total_packets_out: data.packetsSent },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { delta_packets_out: data.deltaPacketsSent },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { delta_packet_delay_ms_out: data.deltaAvgPacketSendDelay },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { total_time_packets_delay_out: data.totalPacketSendDelay },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { total_KBytes_out: data.KBytesSent },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            internal: \"bytesSentChanged\",\n            value: { delta_KBytes_out: data.deltaKBytesSent },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { delta_kbs_out: data.kbsSent },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            internal: \"deviceChanged\",\n            value: { track_out: trackOut },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { level_out: audioLevel },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            internal: \"ssrcIdentifierOut\",\n            value: { ssrc_out: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.SSRC] },\n          },\n        ];\n      }\n      if (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.MEDIA_TYPE] === _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO) {\n        const encoderImplementation = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.ENCODER_IMPLEMENTATION] || null;\n        const videoOutputCodecId = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.CODEC_ID] || null;\n\n        // FF: no media-source, try to find the track from the sender (first track of kind found)\n        if (!trackOut) {\n          const track = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.findOutgoingTrackFromPeerConnectionByKind)(\"video\", _refPC);\n          if (track) {\n            trackOut = track.id;\n            deviceLabel = track.label;\n          }\n        }\n\n        // Encode time\n        const data = extractEncodeTime(bunch, previousSSRCBunch);\n\n        // Video size\n        const outputVideo = extractVideoSize(bunch);\n\n        // limitations\n        const limitationOut = extractQualityLimitation(bunch);\n\n        // Nack & Pli stats\n        const nackPliData = extractNackAndPliCountReceivedWhenSending(\n          bunch,\n          previousSSRCBunch,\n          referenceSSRCBunch,\n        );\n\n        // packets and bytes\n        const dataSent = extractAudioVideoPacketSent(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO, previousSSRCBunch, referenceSSRCBunch);\n\n        return [\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            internal: \"mediaSourceUpdated\",\n            value: { active_out: active },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { device_out: deviceLabel },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { codec_id_out: videoOutputCodecId },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_packets_out: dataSent.packetsSent },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_packets_out: dataSent.deltaPacketsSent },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_packet_delay_ms_out: dataSent.deltaAvgPacketSendDelay },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_time_packets_delay_out: dataSent.totalPacketSendDelay },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_KBytes_out: dataSent.KBytesSent },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            internal: \"bytesSentChanged\",\n            value: { delta_KBytes_out: dataSent.deltaKBytesSent },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_kbs_out: dataSent.kbsSent },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { encoder_out: encoderImplementation },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_encode_frame_ms_out: data.delta_ms_encode_frame },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_frames_encoded_out: data.frames_encoded },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_time_encoded_out: data.total_encode_time },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_nack_received_out: nackPliData.nackCount },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_nack_received_out: nackPliData.deltaNackCount },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_pli_received_out: nackPliData.pliCount },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_pli_received_out: nackPliData.deltaPliCount },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { size_out: outputVideo },\n            internal: \"outputSizeChanged\",\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { limitation_out: limitationOut },\n            internal: \"videoLimitationChanged\",\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            internal: \"deviceChanged\",\n            value: { track_out: trackOut },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { size_pref_out: size },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            internal: \"ssrcIdentifierOut\",\n            value: { ssrc_out: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.SSRC] },\n          },\n        ];\n      }\n      break;\n    }\n    case _utils_models__WEBPACK_IMPORTED_MODULE_0__.TYPE.MEDIA_SOURCE: {\n      break;\n    }\n    case _utils_models__WEBPACK_IMPORTED_MODULE_0__.TYPE.TRACK: {\n      break;\n    }\n    case _utils_models__WEBPACK_IMPORTED_MODULE_0__.TYPE.CODEC:\n      const result = [];\n      // Check for Audio codec\n      Object.keys(previousBunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO]).forEach((ssrc) => {\n        const ssrcAudioBunch = previousBunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO][ssrc];\n        if ((ssrcAudioBunch.codec_id_in === bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.ID]) || (ssrcAudioBunch.codec_id_out === bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.ID])) {\n          const codec = extractAudioCodec(bunch);\n          if (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.ID] === ssrcAudioBunch.codec_id_in) {\n            result.push({ ssrc: ssrcAudioBunch.ssrc, type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO, value: { codec_in: codec } });\n          } else {\n            result.push({ ssrc: ssrcAudioBunch.ssrc, type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO, value: { codec_out: codec } });\n          }\n        }\n      });\n\n      // Check for Video codec\n      Object.keys(previousBunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO]).forEach((ssrc) => {\n        const ssrcVideoBunch = previousBunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO][ssrc];\n        if ((ssrcVideoBunch.codec_id_in === bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.ID]) || (ssrcVideoBunch.codec_id_out === bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.ID])) {\n          const codec = extractVideoCodec(bunch);\n          if (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.ID] === ssrcVideoBunch.codec_id_in) {\n            result.push({ ssrc: ssrcVideoBunch.ssrc, type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO, value: { codec_in: codec } });\n          } else {\n            result.push({ ssrc: ssrcVideoBunch.ssrc, type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO, value: { codec_out: codec } });\n          }\n        }\n      });\n      return result;\n    case _utils_models__WEBPACK_IMPORTED_MODULE_0__.TYPE.REMOTE_INBOUND_RTP: {\n      // get SSRC and associated data\n      const ssrc = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.SSRC];\n      const previousSSRCBunch = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getSSRCDataFromBunch)(ssrc, previousBunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.OUTBOUND);\n      const referenceSSRCBunch = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getSSRCDataFromBunch)(ssrc, referenceReport, _utils_models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.OUTBOUND);\n      if (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.KIND] === _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO) {\n        // Round Trip Time based on RTCP\n        const data = extractRTTBasedOnRTCP(\n            bunch,\n            _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO,\n            referenceSSRCBunch,\n            previousSSRCBunch,\n        );\n\n        // Jitter (out)\n        const jitter = extractLastJitter(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO, previousSSRCBunch);\n\n        // Packets lost\n        const packets = extractAudioVideoPacketLost(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO, previousSSRCBunch, referenceSSRCBunch);\n\n        return [\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { delta_rtt_ms_out: data.rtt },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { total_rtt_ms_out: data.totalRTT },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { total_rtt_measure_out: data.totalRTTMeasurements },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { delta_jitter_ms_out: jitter },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { timestamp_out: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TIMESTAMP] },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { total_packets_lost_out: packets.packetsLost },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { delta_packets_lost_out: packets.deltaPacketsLost },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { percent_packets_lost_out: packets.fractionLost },\n          },\n        ];\n      }\n\n      if (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.KIND] === _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO) {\n        // Round Trip Time based on RTCP\n        const data = extractRTTBasedOnRTCP(\n            bunch,\n            _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO,\n            referenceSSRCBunch,\n            previousSSRCBunch,\n        );\n\n        // Jitter (out)\n        const jitter = extractLastJitter(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO, previousSSRCBunch);\n\n        // Packets lost\n        const packets = extractAudioVideoPacketLost(bunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.VIDEO, previousSSRCBunch, referenceSSRCBunch);\n\n        return [\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_rtt_ms_out: data.rtt },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_rtt_ms_out: data.totalRTT },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_rtt_measure_out: data.totalRTTMeasurements },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_jitter_ms_out: jitter },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { timestamp_out: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TIMESTAMP] },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { total_packets_lost_out: packets.packetsLost },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { delta_packets_lost_out: packets.deltaPacketsLost },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.VIDEO,\n            value: { percent_packets_lost_out: packets.fractionLost },\n          },\n        ];\n      }\n      break;\n    }\n    case _utils_models__WEBPACK_IMPORTED_MODULE_0__.TYPE.REMOTE_OUTBOUND_RTP: {\n      // get SSRC and associated data\n      const ssrc = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.SSRC];\n      const previousSSRCBunch = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getSSRCDataFromBunch)(ssrc, previousBunch, _utils_models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.OUTBOUND);\n      const referenceSSRCBunch = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getSSRCDataFromBunch)(ssrc, referenceReport, _utils_models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.OUTBOUND);\n      if (bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.KIND] === _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO) {\n        // Round Trip Time based on RTCP\n        const data = extractRTTBasedOnRTCP(\n          bunch,\n          _utils_models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO,\n          referenceSSRCBunch,\n          previousSSRCBunch,\n        );\n\n        return [\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { delta_rtt_ms_in: data.rtt },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { total_rtt_ms_in: data.totalRTT },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { total_rtt_measure_in: data.totalRTTMeasurements },\n          },\n          {\n            ssrc,\n            type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.AUDIO,\n            value: { timestamp_in: bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TIMESTAMP] },\n          },\n        ];\n      }\n      break;\n    }\n    case _utils_models__WEBPACK_IMPORTED_MODULE_0__.TYPE.TRANSPORT: {\n      const selectedCandidatePairId = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.SELECTED_CANDIDATEPAIR_ID];\n      return [\n        {\n          type: _utils_models__WEBPACK_IMPORTED_MODULE_0__.STAT_TYPE.NETWORK,\n          internal: \"selectedPairChanged\",\n          value: { selected_candidate_pair_id: selectedCandidatePairId },\n        },\n      ];\n    }\n    default:\n      break;\n  }\n\n  // No interesting data\n  return [];\n};\n\nconst extractPassthroughFields = (bunch, passthrough) => {\n  if (!bunch) {\n    return [];\n  }\n  // Example {\"inbound-rtp\": [\"jitter\", \"bytesSent\"]}\n  const fieldsToReport = (passthrough && passthrough[bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.TYPE]]) || [];\n\n  const pass = {};\n  if (fieldsToReport.length > 0) {\n    const ref = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.SSRC] || bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.ID];\n    const kind = bunch[_utils_models__WEBPACK_IMPORTED_MODULE_0__.PROPERTY.KIND] || \"\";\n    const id = `${bunch.type}${kind ? `-${kind}` : \"\"}_${ref}`;\n    fieldsToReport.forEach((field) => {\n      if (field in bunch) {\n        if (!(field in pass)) {\n          pass[field] = {};\n        }\n        pass[field][id] = bunch[field];\n      }\n    });\n  }\n  return pass;\n};\n\n\n//# sourceURL=webpack://WebRTCMetrics/./src/extractor.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WebRTCMetrics)\n/* harmony export */ });\n/* harmony import */ var regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime/runtime.js */ \"./node_modules/regenerator-runtime/runtime.js\");\n/* harmony import */ var regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/log */ \"./src/utils/log.js\");\n/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/config */ \"./src/utils/config.js\");\n/* harmony import */ var _engine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./engine */ \"./src/engine.js\");\n\n\n\n\n\nconst moduleName = \"interface   \";\n\nclass WebRTCMetrics {\n  constructor(cfg) {\n    this._config = (0,_utils_config__WEBPACK_IMPORTED_MODULE_2__.getGlobalConfig)(cfg);\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_1__.info)(moduleName, `welcome to ${this._config.name} version ${this._config.version}`);\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_1__.setVerboseLog)(this._config.verbose || false);\n    this._engine = new _engine__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this._config);\n  }\n\n  /**\n   * Change log level manually\n   * @param {string} level - The level of logs. Can be one of 'TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR', 'SILENT'\n   */\n  setupLogLevel(level) {\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(level);\n  }\n\n  /**\n   * Get the version\n   */\n  get version() {\n    return this._config.version;\n  }\n\n  /**\n   * Get the library name\n   */\n  get name() {\n    return this._config.name;\n  }\n\n  /**\n   * Get the probes\n   */\n  get probes() {\n    return this._engine.probes;\n  }\n\n  /**\n   * Create a new probe and return it\n   * @param {RTCPeerConnection} peerConnection The RTCPeerConnection instance to monitor\n   * @param {Object} options  The option\n   * @return {Probe} The probe created\n   */\n  createProbe(peerConnection, options) {\n    return this._engine.addNewProbe(peerConnection, options);\n  }\n\n  /**\n   * Start all probes\n   */\n  startAllProbes() {\n    this._engine.start();\n  }\n\n  /**\n   * Stop all probes\n   */\n   stopAllProbes() {\n    this._engine.stop();\n  }\n\n  /**\n   * Is running\n   */\n  get running() {\n    return this._engine.isRunning;\n  }\n\n  /**\n   * Is Idle\n   */\n  get idle() {\n    return this._engine.isIdle;\n  }\n\n  /**\n   * Experimental\n   * Remote a probe\n   * @param {Probe} probe\n   */\n  removeProbe(probe) {\n   this._engine.removeExistingProbe(probe);\n  }\n\n  set onresult(callback) {\n    if (callback) {\n      this._engine.registerCallback(\"onresult\", callback);\n    } else {\n      this._engine.unregisterCallback(\"onresult\");\n    }\n  }\n\n  /**\n   * Get the report generated by a probe\n   * @param {Probe} probe\n   */\n  getTicket(probe) {\n    return probe.getTicket();\n  }\n}\n\n\n//# sourceURL=webpack://WebRTCMetrics/./src/index.js?");

/***/ }),

/***/ "./src/live.js":
/*!*********************!*\
  !*** ./src/live.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"doLiveTreatment\": () => (/* binding */ doLiveTreatment)\n/* harmony export */ });\n/* harmony import */ var _utils_rules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/rules */ \"./src/utils/rules.js\");\n\n\nconst getValueFromReport = (data, property, report, withoutSSRC = false) => {\n  if (!report) {\n    return null;\n  }\n\n  if (withoutSSRC) {\n    return data.type in report && property in report[data.type]\n      ? report[data.type][property]\n      : null;\n  }\n  return data.type in report &&\n    data.ssrc in report[data.type] &&\n    property in report[data.type][data.ssrc]\n    ? report[data.type][data.ssrc][property]\n    : null;\n};\n\nconst getValueFromReportValues = (property, reportValues) => reportValues.find((reportValue) => {\n  if (property in reportValue.value) {\n    return reportValue.value[property];\n  }\n  return null;\n});\n\nconst doLiveTreatment = (data, previousReport, values) => {\n  const events = [];\n\n  const addEvent = (at, category, name, ssrc, details) => {\n    events.push({\n      at,\n      ended: null,\n      category,\n      name,\n      ssrc,\n      details,\n    });\n  };\n\n  // track id changed = device changed\n  const compareAndSendEventForDevice = (property) => {\n    const currentTrackId = data.value[property];\n    const previousTrackId = getValueFromReport(data, property, previousReport);\n    const currentDevice = getValueFromReportValues(\"device_out\", values);\n    const oldDevice = getValueFromReport(data, \"device_out\", previousReport);\n    let eventName = \"track-stop\";\n\n    if (previousTrackId !== currentTrackId) {\n      // Message when currentTrackId is null\n      let message = `The existing outbound ${data.type} stream from ${\n        oldDevice || \"unknown\"\n      } has been stopped or muted`;\n      if (currentTrackId && previousTrackId) {\n        // Message when trackId changed\n        message = `The existing outbound ${\n          data.type\n        } device has been changed to ${\n          currentDevice ? currentDevice.value.device_out : \"unknown\"\n        }`;\n        eventName = \"track-change\";\n      } else if (!previousTrackId) {\n        // Message when new trackId\n        message = `A new outbound ${data.type} stream from ${\n          currentDevice ? currentDevice.value.device_out : \"unknown\"\n        } has been started or unmuted`;\n        eventName = \"track-start\";\n      }\n\n      addEvent(new Date().toJSON(), \"call\", eventName, data.ssrc, {\n        message,\n        direction: \"outbound\",\n        kind: data.type,\n        value: currentTrackId,\n        value_old: previousTrackId,\n      });\n    }\n  };\n\n  // width / framerate changed = resolution changed\n  const compareAndSendEventForSize = (property) => {\n    const size = data.value[property];\n    const previousSize = getValueFromReport(data, property, previousReport);\n    const currentActive = property.includes(\"out\")\n      ? getValueFromReportValues(\"active_out\", values)\n      : true;\n    // Only send event for resolution and framerate if there is an active stream\n    if (currentActive) {\n      if (previousSize?.width !== size.width) {\n        addEvent(\n          new Date().toJSON(),\n          \"quality\",\n          !previousSize || previousSize.width < size.width\n            ? \"size-up\"\n            : \"size-down\",\n          data.ssrc,\n          {\n            message: `The resolution of the ${\n              property.includes(\"out\") ? \"outbound\" : \"inbound\"\n            } ${data.type} stream has ${\n              !previousSize || previousSize.width < size.width\n                ? \"increased\"\n                : \"decreased\"\n            } to ${size.width}x${size.height}`,\n            direction: property.includes(\"out\") ? \"outbound\" : \"inbound\",\n            kind: data.type,\n            value: `${size.width}x${size.height}`,\n            value_old: `${previousSize ? previousSize.width : 0}x${\n              previousSize ? previousSize.height : 0\n            }`,\n          },\n        );\n      }\n      if ((0,_utils_rules__WEBPACK_IMPORTED_MODULE_0__.alertOnFramerate)(previousSize?.framerate, size?.framerate)) {\n        addEvent(\n          new Date().toJSON(),\n          \"quality\",\n          !previousSize || previousSize.framerate < size.framerate\n          ? \"fps-up\"\n          : \"fps-down\",\n          data.ssrc,\n          {\n            message: `The framerate of the ${\n              property.includes(\"out\") ? \"outbound\" : \"inbound\"\n            } ${data.type} stream has ${\n              !previousSize || previousSize.framerate < size.framerate\n                ? \"increased\"\n                : \"decreased\"\n            } to ${size.framerate}`,\n            direction: property.includes(\"out\") ? \"outbound\" : \"inbound\",\n            kind: data.type,\n            value: size.framerate,\n            value_old: previousSize ? previousSize.framerate : 0,\n          },\n        );\n      }\n    }\n  };\n\n  // Outbound active property changed: camera or microphone track removed (muted) or added again (unmuted)\n  const compareAndSendEventForOutboundMediaSource = (property) => {\n    const active = data.value[property];\n    const previousActive = getValueFromReport(data, property, previousReport);\n    if (active !== previousActive) {\n      addEvent(\n        new Date().toJSON(),\n        \"call\",\n        active ? \"track-active\" : \"track-inactive\",\n        data.ssrc,\n        {\n          message: `The ${property.includes(\"out\") ? \"outbound\" : \"inbound\"} ${\n            data.type\n          } stream switched to ${active ? \"active\" : \"inactive\"}`,\n          direction: property.includes(\"out\") ? \"outbound\" : \"inbound\",\n          kind: data.type,\n          value: active,\n          value_old: previousActive,\n        },\n      );\n    }\n  };\n\n  // VideoLimitation Change = cpu, bandwidth, other, none\n  const compareAndSendEventForOutboundLimitation = (property) => {\n    const limitation = data.value[property];\n    const previousLimitation = getValueFromReport(\n      data,\n      property,\n      previousReport,\n    );\n\n    if (\n      !previousLimitation ||\n      limitation.reason !== previousLimitation.reason\n    ) {\n      addEvent(\n        new Date().toJSON(),\n        \"quality\",\n        \"limitation\",\n        data.ssrc,\n        {\n          message: `The outbound video stream resolution is ${\n            limitation.reason === \"none\"\n              ? \"no more limited\"\n              : `limited due to ${limitation.reason} reason`\n          }`,\n          direction: property.includes(\"out\") ? \"outbound\" : \"inbound\",\n          kind: data.type,\n          value: limitation.reason,\n          value_old: previousLimitation,\n        },\n      );\n    }\n  };\n\n  // BytesSent changed a lot /10 or x10 = possibly track has been muted/unmuted\n  const compareAndSendEventForBytes = (property) => {\n    const bytesExchanged = data.value[property];\n    const previousBytesExchanged = getValueFromReport(\n      data,\n      property,\n      previousReport,\n    );\n    const currentActive = property.includes(\"out\")\n      ? getValueFromReportValues(\"active_out\", values)\n      : true;\n\n    if (currentActive) {\n      if ((0,_utils_rules__WEBPACK_IMPORTED_MODULE_0__.alertOnPeak)(previousBytesExchanged, bytesExchanged)) {\n        addEvent(\n          new Date().toJSON(),\n          \"quality\",\n          bytesExchanged > previousBytesExchanged ? \"peak-up\" : \"peak-down\",\n          data.ssrc,\n          {\n            message: `A peak has been detected for the ${\n              property.includes(\"out\") ? \"outbound\" : \"inbound\"\n            } ${data.type} steam.`,\n            direction: property.includes(\"out\") ? \"outbound\" : \"inbound\",\n            kind: data.type,\n            value: bytesExchanged,\n            value_old: previousBytesExchanged,\n          },\n        );\n      }\n    }\n  };\n\n  const compareAndSendEventForSelectedCandidatePairChanged = (property) => {\n    const selectedCandidatePairId = data.value[property];\n    const previousSelectedCandidatePairId = getValueFromReport(\n      data,\n      property,\n      previousReport,\n      true,\n    );\n    if (selectedCandidatePairId !== previousSelectedCandidatePairId) {\n      addEvent(new Date().toJSON(), \"signal\", \"route-change\", null, {\n        message: `The selected candidates pair changed to ${selectedCandidatePairId}`,\n        direction: null,\n        kind: null,\n        value: selectedCandidatePairId,\n        value_old: previousSelectedCandidatePairId,\n      });\n    }\n  };\n\n  const compareAndSendEventForNewSSRC = (property) => {\n    const ssrc = data.value[property];\n    const previouSsrc = getValueFromReport(\n      data,\n      property,\n      previousReport,\n    );\n\n    if (ssrc && !previouSsrc) {\n      addEvent(new Date().toJSON(), \"call\", \"track-added\", ssrc, {\n        message: `New track added to the call ${ssrc}`,\n        direction: property.includes(\"in\") ? \"inbound\" : \"outbound\",\n        kind: data.type,\n        value: ssrc,\n        value_old: null,\n      });\n    }\n  };\n\n  switch (data.internal) {\n    case \"deviceChanged\": {\n      if (previousReport) {\n        compareAndSendEventForDevice(\"track_out\");\n      }\n      break;\n    }\n    case \"inputSizeChanged\": {\n      compareAndSendEventForSize(\"size_in\");\n      break;\n    }\n    case \"outputSizeChanged\": {\n      compareAndSendEventForSize(\"size_out\");\n      break;\n    }\n    case \"bytesSentChanged\": {\n      compareAndSendEventForBytes(\"delta_KBytes_out\");\n      break;\n    }\n    case \"bytesReceivedChanged\": {\n      if (previousReport) {\n        compareAndSendEventForBytes(\"delta_KBytes_in\");\n      }\n      break;\n    }\n    case \"mediaSourceUpdated\": {\n      if (previousReport) {\n        compareAndSendEventForOutboundMediaSource(\"active_out\");\n      }\n      break;\n    }\n    case \"videoLimitationChanged\": {\n      compareAndSendEventForOutboundLimitation(\"limitation_out\");\n      break;\n    }\n    case \"selectedPairChanged\": {\n      compareAndSendEventForSelectedCandidatePairChanged(\n        \"selected_candidate_pair_id\",\n      );\n      break;\n    }\n    case \"ssrcIdentifierIn\": {\n      compareAndSendEventForNewSSRC(\"ssrc_in\");\n      break;\n    }\n    case \"ssrcIdentifierOut\": {\n      compareAndSendEventForNewSSRC(\"ssrc_out\");\n      break;\n    }\n    default:\n      break;\n  }\n\n  return events;\n};\n\n\n//# sourceURL=webpack://WebRTCMetrics/./src/live.js?");

/***/ }),

/***/ "./src/probe.js":
/*!**********************!*\
  !*** ./src/probe.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Probe)\n/* harmony export */ });\n/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/log */ \"./src/utils/log.js\");\n/* harmony import */ var _collector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./collector */ \"./src/collector.js\");\n/* harmony import */ var _utils_models__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/models */ \"./src/utils/models.js\");\n/* harmony import */ var _utils_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/helper */ \"./src/utils/helper.js\");\n\n\n\n\n\nclass Probe {\n  constructor(cfg) {\n    this._id =\n      (cfg.pname && cfg.pname.substr(0, 12).padEnd(12, \" \")) || (0,_utils_helper__WEBPACK_IMPORTED_MODULE_3__.createProbeId)();\n    this._moduleName = this._id;\n    (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.info)(this._moduleName, \"probe created\");\n    this._config = cfg;\n    this._collector = new _collector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this._config, this._id);\n  }\n\n  /**\n   * Register a callback to 'onreport'\n   * Unregister when callback is null\n   * Fired when a report is received\n   */\n  set onreport(callback) {\n    if (callback) {\n      this._collector.registerCallback(\"onreport\", callback);\n    } else {\n      this._collector.unregisterCallback(\"onreport\");\n    }\n  }\n\n  /**\n   * Register a callback to 'onticket'\n   * Unregister when callback is null\n   * Fired when a ticket is received\n   */\n  set onticket(callback) {\n    if (callback) {\n      this._collector.registerCallback(\"onticket\", callback);\n    } else {\n      this._collector.unregisterCallback(\"onticket\");\n    }\n  }\n\n  /**\n   * Get the id of the Probe\n   */\n  get id() {\n    return this._id;\n  }\n\n  /**\n   * Get the name of the PeerConnection\n   */\n  get pname() {\n    return this._config.pname;\n  }\n\n  /**\n   * Get the call identifier\n   */\n  get cid() {\n    return this._config.cid;\n  }\n\n  /**\n   * Get the user identifier\n   */\n  get uid() {\n    return this._config.uid;\n  }\n\n  /**\n   * Get the state of the analyzer\n   * Value can be 'running' or 'idle'\n   */\n  get state() {\n    return this._collector.state;\n  }\n\n  set state(newState) {\n    this._collector.state = newState;\n  }\n\n  /**\n   * Add a custom event for that probe\n   * @param {String} name The name of the event\n   * @param {String} category The category of the event. Could be any strings\n   * @param {String} message A description. Could be empty\n   * @param {Date} at Optional. The date of the event.\n   * @param {String} ssrc Optional. The associated ssrc of the stream. Null by default.\n   * @param {Object} value. The value. Null by default\n   * @param {Date} ended Optional. Then end date for period\n   */\n  addCustomEvent(\n    name,\n    category,\n    message,\n    at = new Date(),\n    ssrc = null,\n    value = null,\n    ended = null,\n  ) {\n    let endedAt = null;\n    if (ended) {\n      endedAt = typeof ended === \"object\" ? ended.toJSON() : ended;\n    }\n\n    this._collector.addCustomEvent({\n      at: typeof at === \"object\" ? at.toJSON() : at,\n      ended: endedAt,\n      category,\n      name,\n      ssrc,\n      details: {\n        message,\n        kind: null,\n        direction: null,\n        value,\n        value_old: null,\n      },\n    });\n  }\n\n  /**\n   * Return true if the probe is running\n   */\n  get isRunning() {\n    return this._collector.state === _utils_models__WEBPACK_IMPORTED_MODULE_2__.COLLECTOR_STATE.RUNNING;\n  }\n\n  /**\n   * Return true if the probe is idle\n   */\n  get isIdle() {\n    return this._collector.state === _utils_models__WEBPACK_IMPORTED_MODULE_2__.COLLECTOR_STATE.IDLE;\n  }\n\n  /**\n   * Set the user identifier\n   */\n  updateUserId(value) {\n    this._config.uid = value;\n    this._collector.updateConfig(this._config);\n  }\n\n  /**\n   * Update the call identifier\n   */\n  updateCallId(value) {\n    this._config.cid = value;\n    this._collector.updateConfig(this._config);\n  }\n\n  /**\n   * Set a probe to running state\n   */\n  start() {\n    if (!this.isIdle) {\n      (0,_utils_log__WEBPACK_IMPORTED_MODULE_0__.warn)(this._moduleName, \"probe is already running\");\n      return;\n    }\n    this._collector.start();\n  }\n\n  /**\n   * Set a probe to idle state\n   */\n  stop(forced = false) {\n    if (!this.isRunning) {\n      return;\n    }\n    this._collector.stop(forced);\n  }\n\n  async takeReferenceStats() {\n    return this._collector.takeReferenceStats();\n  }\n\n  async collectStats() {\n    return this._collector.collectStats();\n  }\n\n  getTicket() {\n    return this._collector && this._collector.getTicket();\n  }\n}\n\n\n//# sourceURL=webpack://WebRTCMetrics/./src/probe.js?");

/***/ }),

/***/ "./src/utils/config.js":
/*!*****************************!*\
  !*** ./src/utils/config.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getConfig\": () => (/* binding */ getConfig),\n/* harmony export */   \"getGlobalConfig\": () => (/* binding */ getGlobalConfig)\n/* harmony export */ });\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./models */ \"./src/utils/models.js\");\n/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./log */ \"./src/utils/log.js\");\n\n\n\nconst moduleName = \"config      \";\n\nconst getConfig = (peerConnection, cfg = {}, globalConfig) => {\n  const config = { ...globalConfig, ...cfg };\n\n  if (!cfg.pname) {\n    (0,_log__WEBPACK_IMPORTED_MODULE_1__.warn)(moduleName, `Argument [String] 'cfg.pname' for the peerConnection name or id is missing - use generated '${globalConfig.pname}'`);\n  }\n\n  if (!cfg.cid) {\n    (0,_log__WEBPACK_IMPORTED_MODULE_1__.warn)(moduleName, `Argument [String] 'cfg.cid' for the call name or id is missing - use generated '${globalConfig.cid}'`);\n  }\n\n  if (!cfg.uid) {\n    (0,_log__WEBPACK_IMPORTED_MODULE_1__.warn)(moduleName, `Argument [String] 'cfg.uid' for the user name or id is missing - use generated '${globalConfig.uid}'`);\n  }\n\n  config.pc = peerConnection;\n  return config;\n};\n\nconst getGlobalConfig = (cfg = {}) => {\n  const config = { ..._models__WEBPACK_IMPORTED_MODULE_0__.defaultConfig, ...cfg };\n  config.name = (0,_models__WEBPACK_IMPORTED_MODULE_0__.getLibName)();\n  config.version = (0,_models__WEBPACK_IMPORTED_MODULE_0__.getVersion)();\n  return config;\n};\n\n\n//# sourceURL=webpack://WebRTCMetrics/./src/utils/config.js?");

/***/ }),

/***/ "./src/utils/helper.js":
/*!*****************************!*\
  !*** ./src/utils/helper.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"filteredAverage\": () => (/* binding */ filteredAverage),\n/* harmony export */   \"average\": () => (/* binding */ average),\n/* harmony export */   \"createProbeId\": () => (/* binding */ createProbeId),\n/* harmony export */   \"createCollectorId\": () => (/* binding */ createCollectorId),\n/* harmony export */   \"timeout\": () => (/* binding */ timeout),\n/* harmony export */   \"call\": () => (/* binding */ call),\n/* harmony export */   \"volatilityValuesOfReports\": () => (/* binding */ volatilityValuesOfReports),\n/* harmony export */   \"averageValuesOfReports\": () => (/* binding */ averageValuesOfReports),\n/* harmony export */   \"sumValuesOfReports\": () => (/* binding */ sumValuesOfReports),\n/* harmony export */   \"minValueOfReports\": () => (/* binding */ minValueOfReports),\n/* harmony export */   \"maxValueOfReports\": () => (/* binding */ maxValueOfReports),\n/* harmony export */   \"valuesOfReports\": () => (/* binding */ valuesOfReports),\n/* harmony export */   \"lastOfReports\": () => (/* binding */ lastOfReports),\n/* harmony export */   \"getLastReport\": () => (/* binding */ getLastReport),\n/* harmony export */   \"getSSRCDataFromBunch\": () => (/* binding */ getSSRCDataFromBunch),\n/* harmony export */   \"findTrackInPeerConnectionById\": () => (/* binding */ findTrackInPeerConnectionById),\n/* harmony export */   \"findOutgoingTrackFromPeerConnectionByKind\": () => (/* binding */ findOutgoingTrackFromPeerConnectionByKind)\n/* harmony export */ });\n/* harmony import */ var short_unique_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! short-unique-id */ \"./node_modules/short-unique-id/dist/short-unique-id.js\");\n/* harmony import */ var short_unique_id__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(short_unique_id__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models */ \"./src/utils/models.js\");\n\n\n\nconst shortUUID = new (short_unique_id__WEBPACK_IMPORTED_MODULE_0___default())();\n\nconst getValues = (reports, key, subKey, avoidZeroValue = false, ssrc, withTimestamp = false) => {\n  let arr = reports.map((report) => {\n    if (!subKey) {\n      if (withTimestamp) {\n        return {\n          timestamp: new Date(report.timestamp).toJSON(),\n          value: report[key],\n        };\n      }\n      return report[key];\n    }\n    if (!ssrc) {\n      if (withTimestamp) {\n        return {\n          timestamp: new Date(report.timestamp).toJSON(),\n          value: report[key][subKey],\n        };\n      }\n      return report[key][subKey];\n    }\n    const data = report[key][ssrc];\n    if (data) {\n      if (withTimestamp) {\n        return {\n          timestamp: new Date(report.timestamp).toJSON(),\n          value: data[subKey],\n        };\n      }\n      return data[subKey];\n    }\n    return null;\n  });\n\n  // Avoid null value\n  arr = arr.filter((item) => {\n    if (withTimestamp) {\n      if (avoidZeroValue) {\n        return (item && Number.isFinite(item.value) && item.value > 0);\n      }\n      return item && Number.isFinite(item.value);\n    }\n\n    if (avoidZeroValue) {\n      return (Number.isFinite(item) && item > 0);\n    }\n    return Number.isFinite(item);\n  });\n  if (arr.length === 0) {\n    return [];\n  }\n  return arr;\n};\n\nconst filteredAverage = (nums, defaultValue) => {\n  const filtered = nums.filter((num) => num !== null);\n  if (filtered.length > 0) {\n    return filtered.reduce((a, b) => a + b, 0) / nums.length;\n  }\n  return defaultValue;\n};\n\nconst average = (nums) => (nums.reduce((a, b) => a + b, 0) / nums.length);\n\nconst createProbeId = () => (`probe-${shortUUID()}`);\n\nconst createCollectorId = () => (`coltr-${shortUUID()}`);\n\nconst timeout = (ms) => (new Promise((resolve) => setTimeout(resolve, ms)));\n\nconst call = (fct, context, value) => {\n  if (!context) {\n    fct(value);\n  } else {\n    fct.call(context, value);\n  }\n};\n\nconst volatilityValuesOfReports = (reports, key, subKey, ssrc) => {\n  const values = getValues(reports, key, subKey, true, ssrc);\n  if (values.length === 0) {\n    return null;\n  }\n  const avg = values.reduce((p, c) => p + c, 0) / values.length;\n  if (avg === 0) {\n    return null;\n  }\n\n  const diff = values.map((data) => (Math.abs(avg - data)));\n  const totalDiff = diff.reduce((p, c) => p + c, 0);\n  const volatility = ((totalDiff / values.length) * 100) / avg;\n  return volatility;\n};\n\nconst averageValuesOfReports = (reports, key, subKey, avoidZeroValue = false, ssrc) => {\n  const values = getValues(reports, key, subKey, avoidZeroValue, ssrc);\n  if (values.length === 0) {\n    return null;\n  }\n  return values.reduce((p, c) => p + c, 0) / values.length;\n};\n\nconst sumValuesOfReports = (reports, key, subKey) => {\n  const values = getValues(reports, key, subKey);\n  return values.reduce((p, c) => p + c, 0);\n};\n\nconst minValueOfReports = (reports, key, subKey, ssrc) => {\n  const values = getValues(reports, key, subKey, true, ssrc);\n  if (values.length === 0) {\n    return null;\n  }\n  return Math.min(...values);\n};\n\nconst maxValueOfReports = (reports, key, subKey, ssrc) => {\n  const values = getValues(reports, key, subKey, false, ssrc);\n  if (values.length === 0) {\n    return null;\n  }\n  return Math.max(...values);\n};\n\nconst valuesOfReports = (reports, key, subKey, ssrc) => (getValues(reports, key, subKey, false, ssrc, true));\n\nconst lastOfReports = (reports, key, subKey, ssrc) => {\n  const lastReport = reports.slice().pop();\n  if (!lastReport) {\n    return null;\n  }\n  if (!subKey) {\n    return lastReport[key];\n  }\n  if (!ssrc) {\n    return lastReport[key][subKey];\n  }\n  const ssrcData = lastReport[key][ssrc];\n\n  if (ssrcData) {\n    return ssrcData[subKey];\n  }\n  return null;\n};\n\nconst getLastReport = (reports) => (reports.slice().pop());\n\nconst getSSRCDataFromBunch = (ssrc, bunch, direction) => {\n  if (!bunch) {\n    return null;\n  }\n  const ssrcBunch = {};\n  let audioBunch = bunch[_models__WEBPACK_IMPORTED_MODULE_1__.VALUE.AUDIO][ssrc];\n  if (!audioBunch) {\n    audioBunch = direction === _models__WEBPACK_IMPORTED_MODULE_1__.DIRECTION.INBOUND ? { ..._models__WEBPACK_IMPORTED_MODULE_1__.defaultAudioMetricIn } : { ..._models__WEBPACK_IMPORTED_MODULE_1__.defaultAudioMetricOut };\n  }\n  ssrcBunch[_models__WEBPACK_IMPORTED_MODULE_1__.VALUE.AUDIO] = audioBunch;\n\n  let videoBunch = bunch[_models__WEBPACK_IMPORTED_MODULE_1__.VALUE.VIDEO][ssrc];\n  if (!videoBunch) {\n    videoBunch = direction === _models__WEBPACK_IMPORTED_MODULE_1__.DIRECTION.INBOUND ? { ..._models__WEBPACK_IMPORTED_MODULE_1__.defaultVideoMetricIn } : { ..._models__WEBPACK_IMPORTED_MODULE_1__.defaultVideoMetricOut };\n  }\n  ssrcBunch[_models__WEBPACK_IMPORTED_MODULE_1__.VALUE.VIDEO] = videoBunch;\n  return ssrcBunch;\n};\n\nconst findTrackInPeerConnectionById = (trackId, pc) => {\n  // Get track from PC senders\n  const senderOfTrack = pc.getSenders().find((sender) => sender.track && sender.track.id === trackId);\n\n  if (senderOfTrack) {\n    return senderOfTrack.track;\n  }\n\n  // Get track from PC receivers\n  const receiverOfTrack = pc.getReceivers().find((receiver) => receiver.track && receiver.track.id === trackId);\n\n  if (receiverOfTrack) {\n    return receiverOfTrack.track;\n  }\n  return null;\n};\n\nconst findOutgoingTrackFromPeerConnectionByKind = (kind, pc) => {\n  const senderOfTrack = pc.getSenders().find((sender) => sender.track && sender.track.kind === kind);\n  if (senderOfTrack) {\n    return senderOfTrack.track;\n  }\n  return null;\n};\n\n\n//# sourceURL=webpack://WebRTCMetrics/./src/utils/helper.js?");

/***/ }),

/***/ "./src/utils/log.js":
/*!**************************!*\
  !*** ./src/utils/log.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"setVerboseLog\": () => (/* binding */ setVerboseLog),\n/* harmony export */   \"setLogLevel\": () => (/* binding */ setLogLevel),\n/* harmony export */   \"debug\": () => (/* binding */ debug),\n/* harmony export */   \"trace\": () => (/* binding */ trace),\n/* harmony export */   \"info\": () => (/* binding */ info),\n/* harmony export */   \"warn\": () => (/* binding */ warn),\n/* harmony export */   \"error\": () => (/* binding */ error)\n/* harmony export */ });\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loglevel */ \"./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst getHeader = () => `${new Date().toISOString()} | metrics`;\nconst format = (header, module, message) => `${header} | ${module} | ${message}`;\n\nloglevel__WEBPACK_IMPORTED_MODULE_0__.setDefaultLevel(loglevel__WEBPACK_IMPORTED_MODULE_0__.levels.TRACE);\n\nconst setVerboseLog = (shouldHaveVerboseLog) => {\n  loglevel__WEBPACK_IMPORTED_MODULE_0__.info(format(getHeader(), \"log         \", `set log level to ${shouldHaveVerboseLog ? \"verbose\" : \"info\"}`));\n  loglevel__WEBPACK_IMPORTED_MODULE_0__.setLevel(shouldHaveVerboseLog ? loglevel__WEBPACK_IMPORTED_MODULE_0__.levels.TRACE : loglevel__WEBPACK_IMPORTED_MODULE_0__.levels.INFO);\n};\n\nconst setLogLevel = (logLevel) => {\n  const levels = [...Object.keys(loglevel__WEBPACK_IMPORTED_MODULE_0__.levels)];\n  if (levels.includes(logLevel)) {\n    loglevel__WEBPACK_IMPORTED_MODULE_0__.info(format(getHeader(), \"log         \", `update log level to ${logLevel.toLowerCase()}`));\n    loglevel__WEBPACK_IMPORTED_MODULE_0__.setLevel(logLevel);\n  } else {\n    loglevel__WEBPACK_IMPORTED_MODULE_0__.warn(format(getHeader(), \"log         \", \"Incorrect log level please choose one of \"), levels);\n  }\n};\n\nconst debug = (name, message, data) => {\n  if (data) {\n    loglevel__WEBPACK_IMPORTED_MODULE_0__.debug(format(getHeader(), name, message), data);\n  } else {\n    loglevel__WEBPACK_IMPORTED_MODULE_0__.debug(format(getHeader(), name, message));\n  }\n};\n\nconst trace = (name, message) => {\n  loglevel__WEBPACK_IMPORTED_MODULE_0__.info(format(getHeader(), name, message));\n};\n\nconst info = (name, message) => {\n  loglevel__WEBPACK_IMPORTED_MODULE_0__.info(format(getHeader(), name, message));\n};\n\nconst warn = (name, message) => {\n  loglevel__WEBPACK_IMPORTED_MODULE_0__.warn(format(getHeader(), name, message));\n};\n\nconst error = (name, message) => {\n  loglevel__WEBPACK_IMPORTED_MODULE_0__.error(format(getHeader(), name, message));\n};\n\n\n//# sourceURL=webpack://WebRTCMetrics/./src/utils/log.js?");

/***/ }),

/***/ "./src/utils/models.js":
/*!*****************************!*\
  !*** ./src/utils/models.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getLibName\": () => (/* binding */ getLibName),\n/* harmony export */   \"getVersion\": () => (/* binding */ getVersion),\n/* harmony export */   \"DIRECTION\": () => (/* binding */ DIRECTION),\n/* harmony export */   \"COLLECTOR_STATE\": () => (/* binding */ COLLECTOR_STATE),\n/* harmony export */   \"ENGINE_STATE\": () => (/* binding */ ENGINE_STATE),\n/* harmony export */   \"ICE_CONNECTION_STATE\": () => (/* binding */ ICE_CONNECTION_STATE),\n/* harmony export */   \"ICE_GATHERING_STATE\": () => (/* binding */ ICE_GATHERING_STATE),\n/* harmony export */   \"getDefaultGlobalMetric\": () => (/* binding */ getDefaultGlobalMetric),\n/* harmony export */   \"defaultAudioMetricIn\": () => (/* binding */ defaultAudioMetricIn),\n/* harmony export */   \"defaultAudioMetricOut\": () => (/* binding */ defaultAudioMetricOut),\n/* harmony export */   \"defaultVideoMetricIn\": () => (/* binding */ defaultVideoMetricIn),\n/* harmony export */   \"defaultVideoMetricOut\": () => (/* binding */ defaultVideoMetricOut),\n/* harmony export */   \"getDefaultMetric\": () => (/* binding */ getDefaultMetric),\n/* harmony export */   \"defaultConfig\": () => (/* binding */ defaultConfig),\n/* harmony export */   \"TYPE\": () => (/* binding */ TYPE),\n/* harmony export */   \"PROPERTY\": () => (/* binding */ PROPERTY),\n/* harmony export */   \"VALUE\": () => (/* binding */ VALUE),\n/* harmony export */   \"INFRASTRUCTURE_VALUE\": () => (/* binding */ INFRASTRUCTURE_VALUE),\n/* harmony export */   \"INFRASTRUCTURE_LABEL\": () => (/* binding */ INFRASTRUCTURE_LABEL),\n/* harmony export */   \"STAT_TYPE\": () => (/* binding */ STAT_TYPE)\n/* harmony export */ });\n/* harmony import */ var short_unique_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! short-unique-id */ \"./node_modules/short-unique-id/dist/short-unique-id.js\");\n/* harmony import */ var short_unique_id__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(short_unique_id__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst shortUUID = new (short_unique_id__WEBPACK_IMPORTED_MODULE_0___default())();\n\nconst getLibName = () => (\"WebRTCMetrics\");\nconst getVersion = () => (\"5.3.3\");\n\nconst DIRECTION = {\n  INBOUND: \"inbound\",\n  OUTBOUND: \"outbound\",\n};\n\nconst COLLECTOR_STATE = {\n  IDLE: \"idle\",\n  RUNNING: \"running\",\n  MUTED: \"muted\",\n};\n\nconst ENGINE_STATE = {\n  IDLE: \"idle\",\n  COLLECTING: \"collecting\",\n  ENDED: \"ended\",\n};\n\nconst ICE_CONNECTION_STATE = {\n  NEW: \"new\",\n  CHECKING: \"checking\",\n  CONNECTED: \"connected\",\n  COMPLETED: \"completed\",\n  DISCONNECTED: \"disconnected\",\n  FAILED: \"failed\",\n  CLOSED: \"closed\",\n};\n\nconst ICE_GATHERING_STATE = {\n  NEW: \"new\",\n  GATHERING: \"gathering\",\n  COMPLETE: \"complete\",\n};\n\nconst getDefaultGlobalMetric = () => {\n  const defaultMetrics = {\n    delta_time_to_measure_probes_ms: 0, // Total time to measure all probes\n    delta_time_consumed_to_measure_ms: 0, // Total time to measure at engine level (additional time needed to compute global stats)\n    delta_KBytes_in: 0,\n    delta_KBytes_out: 0,\n    delta_kbs_in: 0,\n    delta_kbs_out: 0,\n    total_time_decoded_in: 0,\n    total_time_encoded_out: 0,\n    probes: [],\n  };\n\n  const metrics = {\n    ...defaultMetrics,\n  };\n\n  return metrics;\n};\n\nconst defaultAudioMetricIn = {\n  level_in: 0,\n  codec_id_in: \"\",\n  codec_in: { mime_type: null, clock_rate: null, sdp_fmtp_line: null },\n  track_in: \"\",\n  ssrc: \"\",\n  direction: DIRECTION.INBOUND,\n  delta_jitter_ms_in: 0,\n  delta_rtt_ms_in: null,\n  delta_packets_in: 0,\n  delta_packets_lost_in: 0,\n  delta_KBytes_in: 0,\n  delta_kbs_in: 0,\n  delta_synthetized_ms_in: 0,\n  delta_playout_delay_ms_in: 0,\n  delta_jitter_buffer_delay_ms_in: 0,\n  total_rtt_ms_in: 0,\n  total_rtt_measure_in: 0,\n  total_packets_in: 0,\n  total_packets_lost_in: 0,\n  total_KBytes_in: 0,\n  total_percent_synthetized_in: 0,\n  total_synthetized_ms_in: 0,\n  total_playout_ms_in: 0,\n  total_time_jitter_buffer_delay_in: 0,\n  total_jitter_emitted_in: 0,\n  percent_synthetized_in: 0,\n  timestamp_in: null,\n  mos_in: 1,\n  mos_emodel_in: 1,\n  mos_fullband_in: 1,\n  percent_packets_lost_in: 0,\n};\n\nconst defaultAudioMetricOut = {\n  active_out: null,\n  level_out: 0,\n  codec_id_out: \"\",\n  codec_out: { mime_type: null, clock_rate: null, sdp_fmtp_line: null },\n  track_out: \"\",\n  device_out: \"\",\n  ssrc: \"\",\n  direction: DIRECTION.OUTBOUND,\n  delta_jitter_ms_out: 0,\n  delta_rtt_ms_out: null,\n  delta_packet_delay_ms_out: 0,\n  delta_packets_lost_out: 0,\n  delta_packets_out: 0,\n  delta_KBytes_out: 0,\n  delta_kbs_out: 0,\n  percent_packets_lost_out: 0,\n  total_rtt_ms_out: 0,\n  total_rtt_measure_out: 0,\n  total_time_packets_delay_out: 0,\n  total_packets_lost_out: 0,\n  total_packets_out: 0,\n  total_KBytes_out: 0,\n  timestamp_out: null,\n  mos_out: 1,\n  mos_emodel_out: 1,\n  mos_fullband_out: 1,\n};\n\nconst defaultVideoMetricIn = {\n  codec_id_in: \"\",\n  codec_in: { mime_type: null, clock_rate: null },\n  direction: DIRECTION.INBOUND,\n  decoder_in: null,\n  track_in: \"\",\n  ssrc: \"\",\n  size_in: { width: 0, height: 0, framerate: 0 },\n  delta_jitter_ms_in: 0,\n  delta_packets_in: 0,\n  delta_packets_lost_in: 0,\n  delta_KBytes_in: 0,\n  delta_kbs_in: 0,\n  delta_glitch_in: { freeze: 0, pause: 0 },\n  delta_decode_frame_ms_in: 0,\n  delta_processing_delay_ms_in: 0,\n  delta_assembly_delay_ms_in: 0,\n  delta_nack_sent_in: 0,\n  delta_pli_sent_in: 0,\n  delta_jitter_buffer_delay_ms_in: 0,\n  percent_packets_lost_in: 0,\n  total_packets_in: 0,\n  total_packets_lost_in: 0,\n  total_KBytes_in: 0,\n  total_glitch_in: { freeze: 0, pause: 0 },\n  total_frames_decoded_in: 0,\n  total_time_decoded_in: 0,\n  total_time_processing_delay_in: 0,\n  total_time_assembly_delay_in: 0,\n  total_time_jitter_buffer_delay_in: 0,\n  total_jitter_emitted_in: 0,\n  total_nack_sent_in: 0,\n  total_pli_sent_in: 0,\n};\n\nconst defaultVideoMetricOut = {\n  active_out: null,\n  codec_id_out: \"\",\n  codec_out: { mime_type: null, clock_rate: null },\n  track_out: \"\",\n  device_out: \"\",\n  ssrc: \"\",\n  direction: DIRECTION.OUTBOUND,\n  encoder_out: null,\n  size_out: { width: 0, height: 0, framerate: 0 },\n  size_pref_out: { width: 0, height: 0, framerate: 0 },\n  delta_jitter_ms_out: 0,\n  delta_rtt_ms_out: null,\n  delta_packet_delay_ms_out: 0,\n  delta_packets_lost_out: 0,\n  delta_packets_out: 0,\n  delta_KBytes_out: 0,\n  delta_kbs_out: 0,\n  delta_encode_frame_ms_out: 0,\n  delta_nack_received_out: 0,\n  delta_pli_received_out: 0,\n  total_rtt_ms_out: 0,\n  total_rtt_measure_out: 0,\n  total_time_packets_delay_out: 0,\n  total_packets_lost_out: 0,\n  total_packets_out: 0,\n  total_KBytes_out: 0,\n  total_time_encoded_out: 0,\n  total_frames_encoded_out: 0,\n  total_nack_received_out: 0,\n  total_pli_received_out: 0,\n  percent_packets_lost_out: 0,\n  limitation_out: { reason: null, durations: null, resolutionChanges: 0 },\n  timestamp_out: null,\n};\n\nconst getDefaultMetric = (previousStats) => {\n  const defaultMetrics = {\n    pname: \"\",\n    call_id: \"\",\n    user_id: \"\",\n    timestamp: null,\n    count: 0,\n    audio: {},\n    video: {},\n    network: {\n      infrastructure: 3,\n      selected_candidate_pair_id: \"\",\n      local_candidate_id: \"\",\n      local_candidate_type: \"\",\n      local_candidate_protocol: \"\",\n      local_candidate_relay_protocol: \"\",\n      remote_candidate_id: \"\",\n      remote_candidate_type: \"\",\n      remote_candidate_protocol: \"\",\n    },\n    data: {\n      total_KBytes_in: 0,\n      total_KBytes_out: 0,\n      delta_KBytes_in: 0,\n      delta_KBytes_out: 0,\n      delta_kbs_in: 0,\n      delta_kbs_out: 0,\n      delta_kbs_bandwidth_in: 0,\n      delta_kbs_bandwidth_out: 0,\n      delta_rtt_connectivity_ms: null,\n      total_rtt_connectivity_ms: 0,\n      total_rtt_connectivity_measure: 0,\n    },\n    experimental: {\n      time_to_measure_ms: 0,\n    },\n    passthrough: {},\n  };\n\n  if (previousStats) {\n    const metrics = {\n      ...previousStats,\n      audio: {},\n      video: {},\n      data: { ...previousStats.data },\n      network: { ...previousStats.network },\n      experimental: { ...previousStats.experimental },\n      passthrough: {},\n    };\n    Object.keys(previousStats.audio).forEach((ssrc) => {\n      metrics.audio[ssrc] = { ...previousStats.audio[ssrc] };\n    });\n    Object.keys(previousStats.video).forEach((ssrc) => {\n      metrics.video[ssrc] = { ...previousStats.video[ssrc] };\n    });\n    return metrics;\n  }\n\n  return {\n    ...defaultMetrics,\n    audio: {},\n    video: {},\n    data: { ...defaultMetrics.data },\n    network: { ...defaultMetrics.network },\n    experimental: { ...defaultMetrics.experimental },\n  };\n};\n\nconst defaultConfig = {\n  refreshEvery: 2000, // Default - generate a report every 2s (in ms). Min 1s.\n  startAfter: 0, // Default - Duration (in ms) to wait before starting to grab the stats. 0 starts immediately\n  stopAfter: -1, // Default - Max duration (in ms) for grabbing the stats. -1 means until calling stop().\n  // keepMaxReport: 50, // Keep the last 50 tickets (new one erases the oldest)\n  verbose: false, // Default - minimal logs\n  pname: `p-${shortUUID()}`, // Default - peer connection name\n  cid: `c-${shortUUID()}`, // Default - call identifier\n  uid: `u-${shortUUID()}`, // Default - user identifier\n  record: false, // Default - no record,\n  ticket: true, // Default - ticket generated and so all reports are kept\n  passthrough: {}, // Access to specific fields directly from the stack {\"inbound-rtp\": [\"jitter\", \"bytesReceived\"]}\n};\n\nconst TYPE = {\n  CANDIDATE_PAIR: \"candidate-pair\",\n  CODEC: \"codec\",\n  INBOUND_RTP: \"inbound-rtp\",\n  LOCAL_CANDIDATE: \"local-candidate\",\n  MEDIA_PLAYOUT: \"media-playout\",\n  MEDIA_SOURCE: \"media-source\",\n  OUTBOUND_RTP: \"outbound-rtp\",\n  REMOTE_CANDIDATE: \"remote-candidate\",\n  REMOTE_INBOUND_RTP: \"remote-inbound-rtp\",\n  REMOTE_OUTBOUND_RTP: \"remote-outbound-rtp\",\n  TRACK: \"track\",\n  TRANSPORT: \"transport\",\n};\n\nconst PROPERTY = {\n  AUDIO_LEVEL: \"audioLevel\",\n  AVAILABLE_OUTGOING_BITRATE: \"availableOutgoingBitrate\",\n  AVAILABLE_INCOMING_BITRATE: \"availableIncomingBitrate\",\n  BYTES_RECEIVED: \"bytesReceived\",\n  BYTES_SENT: \"bytesSent\",\n  CANDIDATE_TYPE: \"candidateType\",\n  CHANNELS: \"channels\",\n  CLOCK_RATE: \"clockRate\",\n  CODEC_ID: \"codecId\",\n  CURRENT_ROUND_TRIP_TIME: \"currentRoundTripTime\",\n  DECODER_IMPLEMENTATION: \"decoderImplementation\",\n  ENCODER_IMPLEMENTATION: \"encoderImplementation\",\n  FRACTION_LOST: \"fractionLost\",\n  FRAME_HEIGHT: \"frameHeight\",\n  FRAME_WIDTH: \"frameWidth\",\n  FRAMES_DECODED: \"framesDecoded\",\n  FRAMES_ENCODED: \"framesEncoded\",\n  FRAMES_PER_SECOND: \"framesPerSecond\",\n  FREEZE_COUNT: \"freezeCount\",\n  HEIGHT: \"height\",\n  QUALITY_LIMITATION_REASON: \"qualityLimitationReason\",\n  QUALITY_LIMITATION_DURATIONS: \"qualityLimitationDurations\",\n  QUALITY_LIMITATION_RESOLUTION_CHANGES: \"qualityLimitationResolutionChanges\",\n  ID: \"id\",\n  JITTER: \"jitter\",\n  JITTER_BUFFER_DELAY: \"jitterBufferDelay\",\n  JITTER_BUFFER_EMITTED_COUNT: \"jitterBufferEmittedCount\",\n  KIND: \"kind\",\n  LOCAL_CANDIDATE_ID: \"localCandidateId\",\n  MEDIA_TYPE: \"mediaType\",\n  MIME_TYPE: \"mimeType\",\n  MEDIA_SOURCE_ID: \"mediaSourceId\",\n  NACK: \"nackCount\",\n  NETWORK_TYPE: \"networkType\",\n  NOMINATED: \"nominated\",\n  RELAY_PROTOCOL: \"relayProtocol\",\n  PACKETS_LOST: \"packetsLost\",\n  PACKETS_RECEIVED: \"packetsReceived\",\n  PACKETS_SENT: \"packetsSent\",\n  PAUSE_COUNT: \"pauseCount\",\n  PLAYOUT_ID: \"playoutId\",\n  PLI: \"pliCount\",\n  PROTOCOL: \"protocol\",\n  PORT: \"port\",\n  REMOTE_CANDIDATE_ID: \"remoteCandidateId\",\n  REMOTE_SOURCE: \"remoteSource\",\n  RESPONSES_RECEIVED: \"responsesReceived\",\n  ROUND_TRIP_TIME: \"roundTripTime\",\n  SDP_FMTP_LINE: \"sdpFmtpLine\",\n  SSRC: \"ssrc\",\n  SELECTED: \"selected\",\n  SELECTED_CANDIDATEPAIR_ID: \"selectedCandidatePairId\",\n  STATE: \"state\",\n  SYNTHETIZED_SAMPLES_DURATION: \"synthesizedSamplesDuration\",\n  TIMESTAMP: \"timestamp\",\n  TRACK_IDENTIFIER: \"trackIdentifier\",\n  TRANSPORT_ID: \"transportId\",\n  TOTAL_ASSEMBLY_TIME: \"totalAssemblyTime\",\n  TOTAL_DECODE_TIME: \"totalDecodeTime\",\n  TOTAL_ENCODE_TIME: \"totalEncodeTime\",\n  TOTAL_PACKETS_SEND_DELAY: \"totalPacketSendDelay\",\n  TOTAL_PLAYOUT_DELAY: \"totalPlayoutDelay\",\n  TOTAL_PROCESSING_DELAY: \"totalProcessingDelay\",\n  TOTAL_SAMPLES_COUNT: \"totalSamplesCount\",\n  TOTAL_SAMPLES_DURATION: \"totalSamplesDuration\",\n  TOTAL_ROUND_TRIP_TIME: \"totalRoundTripTime\",\n  TOTAL_ROUND_TRIP_TIME_MEASUREMENTS: \"roundTripTimeMeasurements\",\n  TYPE: \"type\",\n  WIDTH: \"width\",\n};\n\nconst VALUE = {\n  SUCCEEDED: \"succeeded\",\n  AUDIO: \"audio\",\n  VIDEO: \"video\",\n  DATA: \"data\",\n};\n\nconst INFRASTRUCTURE_VALUE = {\n  ETHERNET: 0,\n  CELLULAR_5G: 2,\n  WIFI: 3, // default\n  CELLULAR_4G: 5,\n  CELLULAR: 10,\n};\n\nconst INFRASTRUCTURE_LABEL = {\n  ETHERNET: \"ethernet\",\n  CELLULAR_4G: \"cellular\",\n  WIFI: \"wifi\",\n};\n\nconst STAT_TYPE = {\n  AUDIO: \"audio\",\n  VIDEO: \"video\",\n  NETWORK: \"network\",\n  DATA: \"data\",\n};\n\n\n//# sourceURL=webpack://WebRTCMetrics/./src/utils/models.js?");

/***/ }),

/***/ "./src/utils/rules.js":
/*!****************************!*\
  !*** ./src/utils/rules.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"alertOnFramerate\": () => (/* binding */ alertOnFramerate),\n/* harmony export */   \"alertOnPeak\": () => (/* binding */ alertOnPeak)\n/* harmony export */ });\nconst ABSOLUTE_FRAMERATE_CHANGE = 2; // Alert if framerate change > 2 fps\nconst ABSOLUTE_BYTES_THRESHOLD_PERCENT = 50; // Alert if bytes change > 50%\n\nconst alertOnFramerate = (oldFramerate, currentFramerate) => (\n  (oldFramerate && Math.abs(oldFramerate - currentFramerate) > ABSOLUTE_FRAMERATE_CHANGE)\n);\n\nconst alertOnPeak = (oldBytesExchanged, currentBytesExchanged) => (\n  (currentBytesExchanged && Math.abs(oldBytesExchanged - currentBytesExchanged) / (currentBytesExchanged * 100) > ABSOLUTE_BYTES_THRESHOLD_PERCENT)\n);\n\n\n//# sourceURL=webpack://WebRTCMetrics/./src/utils/rules.js?");

/***/ }),

/***/ "./src/utils/score.js":
/*!****************************!*\
  !*** ./src/utils/score.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"computeFullEModelScore\": () => (/* binding */ computeFullEModelScore),\n/* harmony export */   \"computeEModelMOS\": () => (/* binding */ computeEModelMOS),\n/* harmony export */   \"computeMOS\": () => (/* binding */ computeMOS)\n/* harmony export */ });\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./models */ \"./src/utils/models.js\");\n/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ \"./src/utils/helper.js\");\n\n\n\nconst computeScore = (r, forceToMinimal) => {\n  if (forceToMinimal) {\n    return 1;\n  }\n\n  if (r < 0) {\n    return 1;\n  }\n\n  if (r > 100) {\n    return 4.5;\n  }\n\n  return 1 + 0.035 * r + (7.0 / 1000000) * r * (r - 60) * (100 - r);\n};\n\nconst getSSRCReportFrom = (ssrc, report, previousReport, beforeLastReport, direction) => {\n  const currentSSRCReport = (0,_helper__WEBPACK_IMPORTED_MODULE_1__.getSSRCDataFromBunch)(ssrc, report, direction);\n  const previousSSRCReport = (0,_helper__WEBPACK_IMPORTED_MODULE_1__.getSSRCDataFromBunch)(ssrc, previousReport, direction);\n  const beforeLastSSRCReport = (0,_helper__WEBPACK_IMPORTED_MODULE_1__.getSSRCDataFromBunch)(ssrc, beforeLastReport, direction);\n\n  return { currentSSRCReport, previousSSRCReport, beforeLastSSRCReport };\n};\n\nconst computeJitter = (ssrcReport, previousSSRCReport, beforeLastSSRCReport, kind, direction, smoothedRange) => {\n  const jitterValues = [];\n  const currentValue = direction === _models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.INBOUND ? ssrcReport[kind].delta_jitter_ms_in : ssrcReport[kind].delta_jitter_ms_out;\n  // Current value weighted to 4\n  jitterValues.push(currentValue, currentValue, currentValue, currentValue);\n  if (smoothedRange > 1) {\n    const previousValue = direction === _models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.INBOUND ? (previousSSRCReport && previousSSRCReport[kind].delta_jitter_ms_in) || null : (previousSSRCReport && previousSSRCReport[kind].delta_jitter_ms_out) || null;\n    // Previous value weighted to 2\n    jitterValues.push(previousValue, previousValue);\n  }\n  if (smoothedRange > 2) {\n    // Before last value weighted to 1\n    jitterValues.push(direction === _models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.INBOUND ? (beforeLastSSRCReport && beforeLastSSRCReport[kind].delta_jitter_ms_in) || null : (beforeLastSSRCReport && beforeLastSSRCReport[kind].delta_jitter_ms_out) || null);\n  }\n  return (0,_helper__WEBPACK_IMPORTED_MODULE_1__.filteredAverage)(jitterValues, 10);\n};\n\nconst computeRTT = (report, ssrcReport, previousReport, previousSSRCReport, beforeLastReport, beforeLastSSRCReport, kind, direction, smoothedRange) => {\n  const rttValues = [];\n  const currentValue = direction === _models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.INBOUND ? ssrcReport[kind].delta_rtt_ms_in || report.data.delta_rtt_connectivity_ms : ssrcReport[kind].delta_rtt_ms_out || report.data.delta_rtt_connectivity_ms;\n  // Current value weighted to 4\n  rttValues.push(currentValue, currentValue, currentValue, currentValue);\n  if (smoothedRange > 1) {\n    const previousValue = direction === _models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.INBOUND ? (previousSSRCReport && (previousSSRCReport[kind].delta_rtt_ms_in || previousReport.data.delta_rtt_connectivity_ms)) || null : (previousSSRCReport && (previousSSRCReport[kind].delta_rtt_ms_in || previousReport.data.delta_rtt_connectivity_ms)) || null;\n    // Previous value weighted to 2\n    rttValues.push(previousValue, previousValue);\n  }\n  if (smoothedRange > 2) {\n    // Before last value weighted to 1\n    rttValues.push(direction === _models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.INBOUND ? (beforeLastSSRCReport && (beforeLastSSRCReport[kind].delta_rtt_ms_in || beforeLastReport.data.delta_rtt_connectivity_ms)) || null : (beforeLastSSRCReport && (beforeLastSSRCReport[kind].delta_jitter_ms_out || beforeLastReport.data.delta_rtt_connectivity_ms)) || null);\n  }\n  return (0,_helper__WEBPACK_IMPORTED_MODULE_1__.filteredAverage)(rttValues, 100);\n};\n\nconst computePacketsLossPercent = (ssrcReport, previousSSRCReport, beforeLastSSRCReport, kind, direction, smoothedRange) => {\n  const packetLossValues = [];\n  const currentValue = direction === _models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.INBOUND ? ssrcReport[kind].percent_packets_lost_in : ssrcReport[kind].percent_packets_lost_out;\n  // Current value weighted to 4\n  packetLossValues.push(currentValue, currentValue, currentValue, currentValue);\n  if (smoothedRange > 1) {\n    const previousValue = direction === _models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.INBOUND ? (previousSSRCReport && previousSSRCReport[kind].percent_packets_lost_in) || null : (previousSSRCReport && previousSSRCReport[kind].percent_packets_lost_out) || null;\n    // Previous value weighted to 2\n    packetLossValues.push(previousValue, previousValue);\n  }\n  if (smoothedRange > 2) {\n    // Before last value weighted to 1\n    packetLossValues.push(direction === _models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.INBOUND ? (beforeLastSSRCReport && beforeLastSSRCReport[kind].percent_packets_lost_in) || null : (beforeLastSSRCReport && beforeLastSSRCReport[kind].percent_packets_lost_out) || null);\n  }\n  return (0,_helper__WEBPACK_IMPORTED_MODULE_1__.filteredAverage)(packetLossValues, 0);\n};\n\nconst computeFullEModelScore = (\n  report,\n  kind = _models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO,\n  previousReport,\n  beforeLastReport,\n  ssrc,\n  direction = _models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.INBOUND,\n  smoothedRange = 3,\n) => {\n  const RoFB = 148; // RoFB is the signal-to-noise ratio\n  const IsFB = 0; // IsFB is the simultaneous impairment factor\n  let Idd = 0; // Idd id the delay impairment factor\n  const A = 0; // A is the advantage factor\n\n  const { currentSSRCReport, previousSSRCReport, beforeLastSSRCReport } = getSSRCReportFrom(ssrc, report, previousReport, beforeLastReport, direction);\n  const packetsLoss = computePacketsLossPercent(currentSSRCReport, previousSSRCReport, beforeLastSSRCReport, kind, direction, smoothedRange);\n  const rtt = computeRTT(report, currentSSRCReport, previousReport, previousSSRCReport, beforeLastReport, beforeLastSSRCReport, kind, direction, smoothedRange);\n  const jitter = computeJitter(currentSSRCReport, previousSSRCReport, beforeLastSSRCReport, kind, direction, smoothedRange);\n\n  const Ta = (rtt + jitter) / 2; // Overall one way delay (ms)\n  const Iee = 10.2 + ((132 - 10.2) * (packetsLoss / (packetsLoss + 4.3)));\n\n  if (Ta > 100) {\n    const x = (Math.log(Ta) - Math.log(100)) / (Math.log(2));\n    const a = x ** 6;\n    const b = (1 + a) ** (1 / 6);\n    const c = (x / 3) ** 6;\n    const d = (1 + c) ** (1 / 6);\n    Idd = 1.48 * 25 * (b - (3 * d) + 2);\n  }\n\n  const Rx = RoFB - IsFB - Idd - Iee + A;\n  const R = Rx / 1.48;\n  return computeScore(R);\n};\n\nconst computeEModelMOS = (\n  report,\n  kind = _models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO,\n  previousReport,\n  beforeLastReport,\n  ssrc,\n  direction = _models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.INBOUND,\n  smoothedRange = 3,\n) => {\n  const { currentSSRCReport, previousSSRCReport, beforeLastSSRCReport } = getSSRCReportFrom(ssrc, report, previousReport, beforeLastReport, direction);\n  const packetsLoss = computePacketsLossPercent(currentSSRCReport, previousSSRCReport, beforeLastSSRCReport, kind, direction, smoothedRange);\n  const rtt = computeRTT(report, currentSSRCReport, previousReport, previousSSRCReport, beforeLastReport, beforeLastSSRCReport, kind, direction, smoothedRange);\n  const jitter = computeJitter(currentSSRCReport, previousSSRCReport, beforeLastSSRCReport, kind, direction, smoothedRange);\n\n  const rx = Math.max(0, 93.2 - packetsLoss);\n  const ry = 0.18 * rx * rx - 27.9 * rx + 1126.62;\n\n  const d = (rtt + jitter) / 2;\n  const h = d - 177.3 < 0 ? 0 : 1;\n\n  const id = 0.024 * d + 0.11 * (d - 177.3) * h;\n\n  const r = ry - id;\n\n  return computeScore(r, packetsLoss > 30);\n};\n\nconst computeMOS = (\n  report,\n  kind = _models__WEBPACK_IMPORTED_MODULE_0__.VALUE.AUDIO,\n  previousReport,\n  beforeLastReport,\n  ssrc,\n  direction = _models__WEBPACK_IMPORTED_MODULE_0__.DIRECTION.INBOUND,\n  smoothedRange = 3,\n) => {\n  const { currentSSRCReport, previousSSRCReport, beforeLastSSRCReport } = getSSRCReportFrom(ssrc, report, previousReport, beforeLastReport, direction);\n  const packetsLoss = computePacketsLossPercent(currentSSRCReport, previousSSRCReport, beforeLastSSRCReport, kind, direction, smoothedRange);\n  const rtt = computeRTT(report, currentSSRCReport, previousReport, previousSSRCReport, beforeLastReport, beforeLastSSRCReport, kind, direction, smoothedRange);\n  const jitter = computeJitter(currentSSRCReport, previousSSRCReport, beforeLastSSRCReport, kind, direction, smoothedRange);\n\n  const codecFittingParameterA = 0;\n  const codecFittingParameterB = 19.8;\n  const codecFittingParameterC = 29.7;\n  const ld = 30;\n  const d = (rtt + jitter) / 2 + ld;\n  const h = d - 177.3 < 0 ? 0 : 1;\n\n  const id = 0.024 * d + 0.11 * (d - 177.3) * h;\n  const ie =\n    codecFittingParameterA +\n    codecFittingParameterB * Math.log(1 + codecFittingParameterC * packetsLoss);\n\n  const r = 93.2 - (ie + id);\n\n  return computeScore(r);\n};\n\n\n//# sourceURL=webpack://WebRTCMetrics/./src/utils/score.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});